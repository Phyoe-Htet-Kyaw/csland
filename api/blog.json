[
    {
        "id": 1,
        "title": "If you want to be a professional web developer",
        "category_id": 1,
        "photo": "images/1.jpg",
        "description": "ခေါင်းစဉ်လေး အတိုင်းပါပဲ။ အကယ်၍ သင်ဟာ professional web developer တစ်ယောက်ဖြစ်ချင်တယ်ဆိုရင်ပေါ့။ ဘာတွေလေ့လာရမလဲ။ ဘယ်လိုလျှောက်လှမ်းရမလဲ ဆိုတာကို ကျွန်တော့်ရဲ့ အတွေ့အကြုံနဲ့ ယှဉ်ပြီးပြောပြသွားမှာပါ။ ပထမဆုံးအနေနဲ့ ဘာတွေလေ့လာရမလဲ။ ဘာတွေလေ့လာရမလဲ ဆိုတာ မပြောခင် Web development ပိုင်းမှာ frontend နဲ့ backend နှစ်ပိုင်းရှိတယ်ဆိုတာ အရင်ပြောပါရစေ။ frontend ဆိုတာ UI (User Interface)/ UX (User Experience) အပိုင်းပါ။ အဓိက အားဖြင့် user တစ်ယောက် မျက်စိနဲ့ မြင်ရမဲ့ design ကို ဖန်တီးရေးဆွဲရတဲ့အပိုင်းပေါ့။ Web Design အပိုင်းလို့လဲ နားလည်ထားလို့ရပါတယ်။ ဒီ Web Design အပိုင်းမှာ ဘာတွေလေ့လာရမလဲဆို Basic နဲ့ Advanced Level နှစ်မျိုး ခွဲပြောပါ့မယ်။ Basic မှာဆို HTML, CSS, Bootstrap, Javascript, JQuery ဒီငါးခုပါ။ skill ကြမ်းနေပြီဆိုရင် ဒီ basic ငါးခုနဲ့တင် Frontend လောကမှာ ဘာဆိုလား လုပ်လို့ရပါတယ်။ တစ်ခုစီရဲ့အကြောင်းကို နောက်ထပ် posts တွေမှာ ထပ်ရှင်းပါမယ်။ ဒီ ငါးခုပြီးရင် Backend ပိုင်းကို ဆက်ပြီး ခြေဆန့်ရမှာပါ။ Frontend Advanced Level မှာ ဘာတွေလေ့လာရမလဲဆိုတော့ SPA (Single Page Application) တွေရေးဖို့အတွက် VueJs, ReactJs, AngularJs ဒါတွေ လက်ကိုင်ထားရပါမယ်။ သုံးခုလုံးမလေ့လာနိုင်ရင်တောင် တစ်ခုလောက်ကတော့ လက်စွဲထားရပါမယ်။ ဒီသုံးခုမှာတောင် next level တွေရှိပါသေးတယ်။ ဒါတွေကိုလဲ နောက်မှပြောပါမယ်။ အဓိက ဒီသုံးခုက Website တစ်ခုကို reload မဖြစ်စေပဲ data binding နဲ့ rendering လုပ်သွားတာပါ။ ဥပမာ facebook ကိုကြည့်ပါ။ ReactJs နဲ့ရေးထားတာပါ။ page reload မရှိဘူး။ မြန်ဆန်တယ်။ Design Rendering ကို လိုသလို စီမံလို့ရတယ်။ ဒါရဲ့ next level တွေဆိုတာက state management တွေ ဘာညာပေါ့။ ဟုတ်ပြီ။ ဒီလိုဆို Backend ပိုင်း ဆက်သွားရအောင်။ ဒီဘက်က နဲနဲပိုကျယ်ပြန့်တယ်ဗျ။ အရင်ဆုံး PHP ကို ဂျွတ်နေအောင် လေ့လာရမယ်။ Procedural (Pure PHP), OOP, MVC အကုန်သိနေရမယ်။ ဒါတွေမပိုင်ပဲ ရှေ့မဆက်စေချင်ဘူး။ ပြီးတော့ MySQL, AJAX, JSON (API)တွေကိုဆက်လေ့လာရမှာပါ။ ပိုင်ပြီဆိုရင်တော့ Laravel ကိုသွားစေချင်တယ်။ Laravel က အခုချိန်မှာ version 8 အထိရောက်နေပြီး PHP God Framework အဖြစ် နေမဝင် အင်ပါယာကို သူနယ်ချဲ့နေတာပါ။ တော်ရုံ ERP solution လောက်ကို laravel နဲ့ကောင်းကောင်းကြီး ကျုံးလို့ရပါတယ်။ livewire ဆိုရင်လဲ VueJs, ReactJs, AngularJs တို့လို SPA ပုံစံပါ။ ဒီ့အပြင် သူ့မှာ နောက်ထပ် package တွေ အများကြီးပါ။ MVC Framework ဖြစ်တဲ့အတွက် ရေးရတာလဲ ခြေမြန်လက်မြန် အတော်ရှိပါတယ်။ တော်တော် အရာရောက်တဲ့ PHP framework ပါ။ ဒီအထိရနေရင်တော့ Professional Web Developer အဖြစ် ကောင်းကောင်း လှုပ်ရှားလို့ရနေပါပြီ။ ဆက်ပြီး လေ့လာချင်ရင်တော့ MEAN Stack (MongoDB, ExpressJs, AngularJs, NodeJs), MERN Stack (MongoDB, ExpressJs, ReactJs, NodeJs) နဲ့ Hybrid Mobile Application Development (VueNative, React Native, Flutter, Ionic) ဘာညာ အများကြီး ဆက်လေ့လာနိုင်ပါတယ်။ ဒီလောက်ဆိုရင်တော့ တော်တော် အဆင်ပြေနေပါပြီ။ ကျန်တာကတော့ ကိုယ့်ရဲ့ လေ့လာအားထုတ်မှု၊ ကြိုးစားမှုနဲ့ skill အပေါ်ပဲ မူတည်ပါတယ်။ "
    },
    {
        "id": 2,
        "title": "Emperor of JavaScript",
        "category_id": 1,
        "photo": "images/2.jpg",
        "description": "Web Development ကို လေ့လာနေတဲ့ မိတ်ဆွေတို့ ဒါမှမဟုတ် Web Developer အဖြစ် လုပ်ကိုင်နေတဲ့ မိတ်ဆွေတို့ JavaScript ဆိုတဲ့ နာမည်ကိုတော့ စိမ်းမယ် မထင်ပါဘူး။ 1995 ခုနှစ်က စတင်တည်ထောင်ခဲ့တဲ့ JavaScript နိုင်ငံတော်ကြီးဟာ NodeJs နန်းတက်လာတဲ့နောက်ပိုင်းမှာ Emperor ကြီးအဖြစ် နယ်ချဲ့ကြီးစိုး အင်အားကြီးလာနေပါပြီ။ NodeJs နန်းမတက်ခင် Vanilla JavaScript လက်ထက်ကတော့ လူတစ်ကာ အနှိမ်ခံ ဘဝနဲ့ Browser ထဲမှာသာကျင်လည်ခဲ့တာပါ။ သူ့ရဲ့ အစွမ်းအစဟာ DOM လုပ်ပိုင်ခွင့်နဲ့ JSlibrary အချို့ကိုသာ ကိုင်တွယ်နိုင်ခဲ့တာ ဖြစ်ပြီး အပြည်ပြည်ဆိုင်ရာ Programming Language နဲ့ Platform အဖွဲ့အစည်းမှာ ဘောင်မဝင် တန်းမဝင် မျက်နှာငယ်ခဲ့ရတာပါ။ ဒါပေမဲ့ 2009 ခုနှစ်မှာ NPM စစ်တပ်နဲ့အတူ နန်းတက်လာခဲ့တဲ့ NodeJs ကတော့ Chrome ရဲ့ V8 engine အကူအညီကိုယူ C++ Programming Language နဲ့ နားလည်မှု MOU ရေးထိုးပြီး platform အနှံ့ နယ်ချဲ့သိမ်းလာတာ ခုဆို Machine Learning ဘက်ကလွဲ ကျန်တာ ကုန်သလောက်ဖြစ်နေပါပြီ။ ရေးလိုက်တဲ့ JavaScript code ကို Chrome V8 engine သုံးပြီး C++ code ပြောင်း၊ C++ compiler နဲ့ run ပြီး လုပ်ချင်တာ လုပ်ခွင့်ရလာတဲ့ NodeJs တစ်ယောက် စပြီး နယ်ချဲ့တာ Server (Backend) ပိုင်းကိုပါပဲ။ ထီးနန်းစည်းစိမ်နဲ့ ယစ်မူးသာယာနေတဲ့ PHP လိုမင်းမျိုးကို Request စောင့်စရာမလိုတဲ့ Server Response လို အကွက်နဲ့အတူ ပေါ့ပါး လျှင်မြန်မှု၊ MVC application pattern ရှိမှု၊ NPM စစ်တပ်ကြီးရဲ့ အားကြီးမှု၊ Security အားသာမှုနဲ့ အခြားသော နည်းပညာ အသစ်အဆန်းတွေနဲ့အတူ အနိုင်ယူပြပါတယ်။ Server (Backend) အပိုင်းကို အပိုင်သိမ်းပြီးတဲ့အခါ PHP မင်းကြီးဟာ ဟက်ကော့ကြီး ကျန်ခဲ့ပြီး သူ့ထီးနန်းကို ပြန်ရဖို့အတွက် Laravel စစ်တပ်ကို တည်ဆောက်ကာ PHP version (8) Beta နဲ့အတူ ပြန်လာနေပါပြီ။ ဒါဟာ JavaScript မင်းနေပြည်ရဲ့ ပထမကျူးကျော်စစ်ပါ။ ပြီးတဲ့အခါ MPA (Multi-Page Application) စနစ်တောက်လျှောက်ကျင့်သုံးလာတဲ့ Web Development ကမ္ဘာမှာ သူ့တိုင်းပြည်အတွက် သူကိုယ်တိုင် စနစ်တစ်ခုကို တပ်မကြီး လေးခုခွဲပြီး တည်ဆောက်ပါတယ်။ SPA (Single-Page Application) လို့ခေါ်တဲ့ စနစ်ကို Ember တပ်၊ Google ရဲ့ Angular တပ်၊ Facebook ရဲ့ React တပ်နဲ့ တရုတ်စစ်သူကြီး Evan You ဦးဆောင်တဲ့ Vue တပ်တို့နဲ့အတူ စတင်တည်ဆောက်ပါတယ်။ Frontend နယ်ပယ်မှာ ကျင်လည်နေတဲ့ Web Development ကမ္ဘာသူ ကမ္ဘာသားတွေအဖို့ လျှင်မြန်သွက်လက်လှတဲ့ ဒီ SPA စနစ်ဟာ သွားရည်ကျစရာဖြစ်လာပါတယ်။ Two-Databinding, State Management, Event Handling, Component Composition တို့နဲ့အတူ Page Reload မဖြစ်တဲ့ အရသာဟာ JavaScript တိုင်းပြည်ရဲ့ အဖိုးတန်ဆုံး ထုန်ကုန်ပါပဲ။ ဒီနည်းနဲ့ SPA နယ်ကို ကိုယ်တိုင်ထူထောင်ပြီး ထပ်နယ်ချဲ့ပါတယ်။ ဒီလိုနဲ့ မပြီးသေးပါဘူး။ အာသာမပြေလှတဲ့ NPM စစ်တပ်ကြီးကို ဦးဆောင်ထားတဲ့ NodeJs ဘုရင်ဟာ JavaScript ကို ပိုမိုအင်အားကြီးအောင် upgrade မြှင့်ပါတယ်။ Facebook အပိုင် React တပ်မကြီးရဲ့ JSX နည်းပညာနဲ့ ECMAscripts တို့ကို အသုံးပြုပြီး JavaScript တိုင်းပြည်ကြီး ယခင်ထက်ပိုတိုးတက်အောင် ဆောင်ရွက်ပါတယ်။ ECMAscripts ဆို JavaScript ကြီး စတည်ထောင်ထဲက နည်းပညာဆိုပေမဲ့လို့ 2015 ခုနှစ် ES5 ကစ နှစ်စဉ် နှစ်စဉ် Upgrade မြှင့်လာရင်း သူတို့ရဲ့ တိုင်းပြည်ကြီးကို ပိုမို တိုးတက်အောင်ဆောင်ရွက်လာပါတယ်။ ဒီ့အပြင် သူတို့က အငြိမ်မနေပဲ Facebook ရဲ့ React တပ်မ ကို အသုံးပြုပြီး Mobile Application Development ဘက်ကို နယ်စချဲ့ပါတယ်။ ပိုမိုအားကောင်းတဲ့ နည်းနဲ့ကို နယ်ချဲ့တာပါ။ Mobile Development မှာ Android နဲ့ IOS ဆိုပြီး နှစ်နိုင်ငံ တင်းမာမှုကို ကြားကနေ ချစ်ကြည်ရေးဝင်ပေးပြီး Hybrid ဆိုတဲ့ နည်းပညာနဲ့ ချုပ်လိုက်ပါတယ်။ ဒါကို React ရဲ့ တပည့် React Native ဆိုတဲ့ တပ်နဲ့အတူ Ionic, Monaca, Vue Native အစရှိတဲ့ တပ်တွေနဲ့ ဝင်တိုက်ပါတယ်။ ဒီတော့ ခဲတစ်လုံးနဲ့ ငှက်နှစ်ကောင်ပစ်သလို Android နဲ့ IOS သီးခြားနှစ်နိုင်ငံကို JavaScript က သိမ်းပိုက်လိုက်ပါတယ်။ PWA (Progressive Web App) ဆိုတဲ့ Standalone web page နည်းပညာကိုလဲ Google ရဲ့ အကူအညီနဲ့အတူ Android ကော IOS ကော နှစ်နိုင်ငံလုံးကို ဆွဲချုပ်ထားပါတယ်။ ဒီလိုနဲ့ Android Development ကလဲ JavaScript ရဲ့ လက်အောက်ခံဖြစ်သွားပါတယ်။ ဒါက JavaScript တို့ရဲ့ ဒုတိယကျူးကျော်စစ်ပါ။ နောက်ဆုံးမှာ JavaScript တို့ ဘယ်လောက်ထိရဲတင်းပြီး အင်အားကြီးလာလဲဆိုရင် Programming Language အဖွဲ့အစည်းရဲ့ အင်အားကြီး နိုင်ငံတွေဖြစ်တဲ့ C++, Java, C#, Python တို့ရဲ့ နယ်မြေအတွင်းရှိတဲ့ Window Form Application အပိုင်းထိပါ ကျူးကျော်ရန်စ လာပါတယ်။ ElectronJs လို့ခေါ်တဲ့ စစ်တပ်နဲ့အတူ စစ်ခင်းတိုက်ယူတာပါ။ တစ်ဆက်ထဲမှာပဲ Game Development 2D 3D ဘက်ကိုလဲ BabylonJs, PixiJs စစ်တပ်ကိုဦးဆောင်ကာ နယ်ချဲ့နေပါတယ်။ ဒါတွေဟာလဲ JavaScript တိုင်းပြည်ရဲ့ တတိယကျူးကျော်စစ်နဲ့ စတုတ္ထကျူးကျော်စစ်ပါ။ ကျူးကျော်စစ်များဆက်တိုက်ဆိုသလို ဆင်နွှဲနေစဉ်အတွင်းမှာပဲ NodeJs ဘုရင်ကြီးဟာ သူ့သားနှစ်ယောက်ကို သူမရှိတော့တဲ့အချိန် JavaScript တိုင်းပြည်ကြီးကို ဒီ့ထက်ပိုကြမ်းအောင် ဆောင်ရွက်နိုင်ဖို့ အိမ်ရှေ့စံရာထူးပေးခဲ့ပါတယ်။ ဒီသားနှစ်ယောက်ကတော့ အဖေ့ရဲ့ ပြုစုသင်ကြားပေးမှုတွေနဲ့ ကြီးပြင်းလာတဲ့ သားကြီး AdonisJs နဲ့ အဖေကို တနေ့ကျ အနိုင်ယူပြမယ်ဆိုပြီး အမြဲကြုံးဝါးနေတဲ့ သားငယ် denoJs ပါပဲ။ ဒီသားနှစ်ယောက် ကျန်ရှိနေတဲ့ Machine Learning နယ်မြေကို ဆက်လက်ကြီးစိုးနိုင်မလားဆိုတာ စောင့်ကြည့်ရမှာပါ။ လောလောဆယ် အဲ့နယ်မြေရဲ့ ရေမြေ့သခင် ပြည့်ရှင်မင်းကတော့ Python မင်းတရားကြီးပါပဲ။ ဆိုတော့ခါ NodeJs ဦးဆောင်တဲ့ NPM စစ်တပ်နဲ့ JavaScript တိုင်းပြည်ကြီးဟာ နေမဝင်ပါယာကြီးကို တည်ထောင်ရင်း သူအမြဲ မိန့်တဲ့ မိန့်ခွန်းတစ်ခုရှိပါတယ်။ အဲ့တာကတော့ 'Everything is JavaScript'."
    },
    {
        "id": 3,
        "title": "Object Oriented Programming (OOP)",
        "category_id": 3,
        "photo": "images/3.jpg",
        "description": "ဘယ် Programming Language ပဲ လေ့လာ လေ့လာ Procedural အဆင့်ပြီးရင် OOP level ကို တက်လှမ်းရ စမြဲပါပဲ။ OOP မသိရင် အကြီးကြီးတွေ ရေးဖို့ အဆင်မပြေလှပါဘူး။ အဲ့တော့ OOP အကြောင်း ကျွန်တော် သိသလောက်ရှင်းပြပါမယ်။\n\nOOP ဆိုတာ Object-Oriented Programming လို့ခေါ်တဲ့ Programming paradim တစ်မျိုးပါ။ Object တွေကို အခြေခံပြီး ရေးသွားတဲ့ paradim ရေးဟန် တစ်မျိုးပါ။\n\nClass တွေ ခွဲပြီး ရေးမယ် ပြန်ချိတ်မယ်။ အဲ့ Class တွေကို Object အဖြစ် ပြန်ခေါ်ပြီး သုံးမယ်။ ဒါမျိုးပါ။ တကယ်တော့ ဒီ့ထက် deep ဖြစ်ပါတယ်။ ဒါက နားလည်လွယ်အောင်ပြောပြတာပါ။\n\nPrinciples of OOP\nOOP လို့ ပြောလိုက်တာနဲ့ OOP ရဲ့ ဒီ အခြေခံ Principles တွေကို သိထားရပါမယ်။ ဒါတွေကတော့\n\nObject\nObject ရဲ့ အဓိပ္ပါယ်က ဘာလဲဆိုရင် အရာဝတ္ထုတိုင်းဟာ Object ပါ။ ဒီတော့ နားမရှုပ်အောင် Programming ကို ဖယ်ပြီး ပြောပါရစေ။ ကျွန်တော်တို့ လက်တွေ့မှာ မြင်နေရတဲ့ အရာဝတ္ထုတွေ အားလုံးဟာ Object ပါ။ ခဲတံ၊ ပေတံ၊ ဘောပင်၊ စာအုပ်၊ ကား၊ လှေ၊ အိမ်၊ လူ ဒါတွေ အားလုံးဟာ  Object ပါ။ အဲ့တော့ programming နဲ့ ပြန်ယှဉ်ရင် Programming မှာ ဘယ်အရာတွေကို Object လို့ခေါ်မလဲ? အရာဝတ္ထုတိုင်းကို object လို့ ခေါ်တဲ့အတွက် variable ဟာ object ပါ။ datatype တွေဟာလဲ object ပါ။ method ဟာလဲ object ပါ။ သေးသေးကြီးကြီး အရာအားလုံးဟာ object ပါ။\n\nClass\nအဲ့တော့ အရာဝတ္ထုတိုင်းဟာ Object ဆိုတာကို နားလည်ရင် အဲ့ object တွေကို စုထားတဲ့ အရာကို class လို့ ခေါ်ပါတယ်။\n\nprogramming ကိုဖယ်ပြီး လက်တွေ့နဲ့ပြောရရင် ခဲတံတွေကို စုထားတဲ့ ကွန်ပါဘူးဆိုရင် ခဲတံဟာ object ဖြစ်ပြီး ကွန်ပါဘူးဟာ Class ဖြစ်ပါမယ်။ ဒီလိုပါပဲ ကားတွေကို စုထားတဲံ ကားပါကင်ဆိုရင် ကားတွေဟာ object ဖြစ်ပြီး ကားပါကင်ဟာ class ဖြစ်ပါမယ်။ ဒီတော့ Programming နဲ့ ပြန်ပြောရရင် Variable တွေ Algorithm တွေ data structure တွေကို စုထားတာ method ဆိုရင် Variable, Algorithm, DataType, DataStructure ဘာညာ အားလုံးဟာ object ဖြစ်ပြီး method ဟာ class ဖြစ်ပါမယ်။ ဒီတော့ method တွေဟာ class ဖြစ်တဲ့ဆိုရင် method တွေကို စုထားတဲ့ file ကို class လို့ခေါ်ပါတယ်။\n\nInheritance\nInheritance က ဘာလဲဆိုတော့ နားလည်အောင်ပြောရရင် လှမ်းချိတ်တာပေါ့။ လက်တွေ့နဲ့ပြောရရင် မိဘနဲ့ သားသမီး ဆက်ဆံရေးလိုမျိုးပေါ့။ သားသမီးကို မိဘက မွေးထုတ်ထားတဲ့အတွက် မိဘဆီကနေ လိုချင်တာတောင်းလို့ရသလိုမျိုး​ပေါ့။ သားသမီးက မိဘကို inheritance လှမ်းလုပ်ထားတဲ့အတွက် ဘာလိုလို မိဘဆီက အဆင်သင့် လက်ဖြန့်တောင်းရုံပဲ။ (ဥပမာနော် ဥပမာ😁😁) အဲ့တော့ programming နဲ့ပြန်ပြောရရင် Class B က Class A ကို inheritance လှမ်းလုပ်မယ်ဆိုပါဆို့။ ဒါဆို Class A က Parent Class ဖြစ်ပြီး Class B က Child Class ဖြစ်သွားမယ်။ အဲ့တော့ Child Class (Class B) က Parent Class (Class A) ထဲကရှိသမျှ objects တွေ (Methods and Variables) တွေအကုန်လုံးကို ခေါ်သုံးလို့ရသွားမယ်။ ဒါ inheritance ရဲ့ သဘောတရားပါ။ inheritance လုပ်တော့မယ်ဆို သူ့ရဲ့ keyword (extends) ဆိုတာကို သုံးရမှာပါ။\n\nPolymorphism\nPolymorphism ဆိုတာ ဘာလဲဆိုရင် အလုပ်တစ်ခုကို မတူညီတဲ့ နည်းလမ်းတွေနဲ့ အလုပ်လုပ်တာကိုပြောတာပါ။ လက်တွေ့နဲ့ယှဉ်ပြီးပြောရရင်တော့ လူတစ်ယောက်က အိမ်မွေးတိရစ္ဆာန် သုံးကောင် မွေးထားတယ်။ ခွေးရယ် ကြောင်ရယ် ဘဲရယ်ပေါ့။ အဲ့တော့ အဲ့လူက သူ့အိမ်မွေး တိရစ္ဆာန်တွေကို စကားပြောစမ်းဆိုတဲ့ task တခုပေးလိုက်မယ်ဆိုပါဆို့။ အဲ့တော့ ခွေးက ဝုတ်ဝုတ်ဆိုပြီးပြောမယ် ကြောင်က ညောင်ညောင် ဆိုပြီးပြောမယ်။ ဘဲက ဂတ်ဂတ် ဆိုပြီးပြောမယ်။ တိရစ္ဆာန်သုံးကောင်က ပြောတဲ့ အသံမတူပေမဲ့ စကားပြောတဲ့ Task ကို အောင်မြင်စွာလုပ်ဆောင်နိုင်တယ်။ ဆိုလိုချင်တာက အလုပ်တစ်ခု လုပ်ခိုင်းလိုက်မယ် အဲ့အလုပ်ကို သင့်လျှော်တဲ့ နည်းလမ်းပေါင်းစုံနဲ့ အလုပ်လုပ်သွားတယ်ပေါ့။ programming နဲ့ယှဉ်ပြီးပြောရရင် polymorphism ကို သုံးပြီးရေးမယ်ဆိုရင် method overloading နဲ့ method overriding ကို သုံးရတယ်။ အဲ့နှစ်ခုရဲ့ သဘောတရားက method name အတူတူပေးထားတယ်။ တောင်းဆိုတဲ့ parameter အရေအတွက် or parameter datatype အမျိုးအစား ကွဲသွားတယ်။ ဥပမာ function A ဆိုတဲ့ method နှစ်ခုရှိမယ်။ ပထမ function A method က parameter နှစ်ခုတောင်းမယ်။ ဒုတိယ function B က parameter သုံးခုတောင်းမယ်ဆိုပါစို့။ အဲ့တော့ object လှမ်းခေါ်ပြီး function A ကို run တော့မယ်ဆိုရင် parameter ထည့်ပေးရတော့မယ်။ ထည့်လိုက်တဲ့ parameter က နှစ်ခုဆိုရင် ပထမ function A method ကို အလုပ်လုပ်ပြီး ထည့်လိုက်တဲ့ parameter သုံးခုဆို ဒုတိယ function B method ကို သွားအလုပ်လုပ်ပါတယ်။ ဒါက polymorphism ပါ။\n\nAbstraction\nAbstraction ကတော့ method တွေကို လျှိ့ဝှက်ရေးပြီး ပြန်သုံးတယ်လို့ မှတ်ယူရင် ရပါတယ်။ ဥပမာအနေနဲ့ လက်တွေ့မှာဆိုရင် ကျွန်တော်တို့ ဖုန်းပြောတယ်။ ဖုန်းပြောဖို့အတွက် ဖုန်းခေါ်တဲ့သူက outcome call က operator ဆီသွားမယ် အဲ့ကတဆင့် ဖုန်းလက်ခံသူဆီ income call ဝင်မယ်။ ကျွန်တော်တို့ ဒီလောက်ပဲ သိထားတာပါ။ သူ့ procedure ကို။ တကယ်က အဲ့ထက်ပိုရှုပ်ထွေးပါတယ်။ အဲ့ရှုပ်ထွေးတဲ့ procedure ကိုလဲ operator က network သမားတွေကလွဲရင် ဘယ်သူမှ ပိုမသိနိုင်ပါဘူး။ ဒီသဘောပါပဲ။ abstraction ကိုသုံးမယ်ဆိုရင် သူ့ရဲ့ keyword ဖြစ်တဲ့ abstract ဆိုတဲ့ keyword ကို class ရဲ့ ရှေ့မှာ ရေးပါတယ်။ (ဥပမာ abstract class A) အဲ့တော့သူ့ကို extends လှမ်းလုပ်တဲ့ class ကနေ method တွေရေးပြီး သူကနေ abstract keyword နဲ့ထိုင်ခေါ်နေရင် method တွေက ဘယ်က အလုပ်လုပ်လို့ လုပ်မှန်းမသိ ဖြစ်သွားပါတယ်။ ဒါက abstraction ပါ။\n\nEncapsulation\nEncapaulation ဆိုတာ ဘာလဲ အရင်မပြောခင် Capsule ဆိုတာ ဘာလဲ အရင်ပြောပါမယ်။ Capsule ရဲ့ အဓိပ္ပါယ်က ဆေးတောင့်ပါ။ ကျွန်တော်တို့နေမကောင်းရင် သောက်နေကျ ဆေးတောင့်လေးတွေကိုပြောတာပါ။ အဲ့ဆေးတောင့်လေးတွေဟာ ဆေးအမှုန့်လေးတွေကို စုထားတာပါ။ အဲ့တော့ အဲ့ဆေးကို သောက်ရင် capsule က အလုပ်မလုပ်ပဲ အဲ့ capsule ထဲက ဆေးမှုန်တွေက အလုပ်လုပ်သွားတာပါ။ ဒီသဘောပါပဲ။ programming မှာ method တွေ အားလုံးကို စုပြီးရေးထားတဲ့ file ကို class လို့ခေါ်ကြောင်းပြောခဲ့ပါတယ်။ အဲ့လို စုပြီးတခုထဲ ရေးထားတာ (Binding) လုပ်ထားတာကို encapsulation လို့ခေါ်ပါတယ်။\n\n"
    },
    {
        "id": 4,
        "title": "Access Modifier in PHP",
        "category_id": 2,
        "photo": "images/4.jpg",
        "description": "Access Modifier ဆိုတာ ဘာလဲဆိုရင် နားလည်အောင်ပြောရရင်တော့ ကျွန်တော်တို့ declare လုပ်ထားတဲ့ class တွေ၊ method တွေ၊ variable တွေကို ဘယ်လောက်အတိုင်းအတာအထိ အသုံးပြုခွင့်ပေးမလဲ (Access လုပ်ခွင့်ပေးမလဲ) ဆိုပြီး Modify လုပ်ပေးတဲ့ keyword တွေကို ခေါ်တာပါ။ အဲ့တော့ PHP မှာ ရှိတဲ့ Access Modifier တွေကို လေ့လာကြည့်ရအောင်။\n\nSample Code ကတော့ ဒီလိုမျိုးပါ။\n\nClass Test{\n\tprotected $name = 'PHP';\n\tpublic function returnName(){\n\t\treturn $this->name;\n\t}\n}\n\npublic - ကျွန်တော်တို့ဟာ declare လုပ်လိုက်တဲ့ variable ရဲ့ အရှေ့မှာ ဖြစ်ဖြစ် method ရဲ့ အရှေ့မှာ ဖြစ်ဖြစ် public ဆိုတဲ့ Access Modifier ကိုကြေညာလိုက်မယ်ဆိုရင် အဲ့ variable ဒါမှမဟုတ် method ကို project တစ်ခုလုံးရဲ့ ကြိုက်တဲ့နေရာကနေ အချိန်မရွေး လှမ်း access လုပ်လို့ရနိုင်ပါတယ်။ (ခေါ်သုံးလို့ရနိုင်ပါတယ်။)\n\nprivate - ဒီ modifier နဲ့ ကြေညာလိုက်ရင်တော့ ကျွန်တော်တို့ရဲ့ variable ဒါမှမဟုတ် method ကို ကြေညာထားတဲ့ class အတွင်းမှာပဲ သုံးလို့ရပါမယ်။ တခြား ဘယ်နေရာကမှ access လုပ်လို့မရပါဘူး။\n\nprotected - ဒီ modifier လဲ private access modifer လိုပါပဲ။ ကြေညာထားတဲ့ class အတွင်းကပဲ ခေါ်လို့ရပါတယ်။ ဒါပေဲ့ private နဲ့ မတူညီတာက ကြေညာထားတဲ့ Class အတွင်းမှာပဲ သုံးလို့ရတဲ့အပြင် အဲ့ class ကို inheritance (extends) လှမ်းလုပ်ထားတဲ့ class တွေကပါ access လုပ်လို့ရနိုင်မှာဖြစ်ပါတယ်။\n\nabstract - ဒီ modifier ကတော့ variable တွေကို ကြေညာလို့မရပါဘူး Class နဲ့ method အရှေ့မှာပဲ ကြေညာလို့ရပါတယ်။ အပေါ်က access modifier သုံးခုကတော့ Class တွေရှေ့မှာ ကြေညာလို့မရပါဘူး။ Variable နဲ့ Method အရှေ့မှာပဲ ကြေညာလို့ရတာပါ။ ဘာလို့ဒီ abstract က Class နဲ့ Method အရှေ့မှာပဲ ကြေညာလို့လဲဆိုရင် ဒီ abstract access modifier ဟာ OOP မှာ abstraction ရေးတော့မယ်ဆိုရင် သုံးရတဲ့ အတွက်ကြောင့်ပါ။ ဥပမာ\n\nabstract class ParentClass{\n\tpublic $name = 'PHP';\n\tabstract function saySomething();\n}\n\nclass ChildClass extends Parent Class{\n\tpublic function saySomething(){\n\t\treturn $this->name . ' is very awesome!';\n\t}\n}\n\nfinal - ဒီ access modifier ကိုလဲ Class နဲ့ method အရှေ့မှာပဲ ကြေညာလို့ရပါတယ်။ ဒီ access modifier ကိုကြေညာလိုက်ရင် အဲ့ကြေညာခံရတဲ့ Class ဒါမှမဟုတ် method name နဲ့ တူတဲ့ အခြား class ဒါမှမဟုတ် method ရဲ့ override လုပ်ချင်း မခံရတော့ပါဘူး။ ဆိုလိုချင်တာက အဲ့ class or method က unique ဖြစ်သွားပါတယ်။ တခြား class or method ရေးတဲ့အခါ name တူလို့မရတော့ပါဘူး။ Polymorphism နဲ့ လုံးဝဆန့်ကျင်ဘက်ပါ။ Polymorphism မဖြစ်စေချင်ရင် ဒီ modifier ကို သုံးနိုင်ပါတယ်။ အောက်က ဇယားကတော့ ဘယ် access modifier က class, method, variable တွေရှေ့မှာ ကြေညာလို့ရသလဲဆိုတာ ပြထားတာပါ။\n\n"
    },
    {
        "id": 5,
        "title": "Constructor & Destructor",
        "category_id": 2,
        "photo": "images/5.jpg",
        "description": "PHP OOP articles တွေရေးလာတာ ဒါနဲ့ဆို သုံးခုမြောက်ပါ။ ဒီတစ်ခေါက်မှာတော့ PHP OOP မှာပါတဲ့ constructor နဲ့ destructor function အကြောင်းရှင်းပြမှာဖြစ်ပါတယ်။\n\nConstructor\nconstructor function ရဲ့ keyword က __construct() ဖြစ်ပြီး ရေးမယ်ဆိုရင် ဒီလိုရေးရပါတယ်။\n\npublic function __construct(){\n\t// Your code is here\n}\n\nconstructor function ကို ရေးလိုက်ရင် ဘာဖြစ်သွားမလဲ ဆိုတော့ Class တစ်ခု ကို Object အနေနဲ့ခေါ်လိုက်ပြီဆိုပါစို့။ အဲ့လို Object အနေနဲ့ class ထဲက method တစ်ခုကို ဆွဲခေါ်ရင် အဲ့ခေါ်တဲ့ method ကို အရင်သွား access မလုပ်ပဲ constructor function ကို အရင်ထ run ပါတယ်။ တံခါးမှူးလိုပေါ့။ ဘယ် method ကို object ခေါ် run run သူက အရင်အလုပ်ထလုပ်ပါတယ်။ သူလုပ်စရာရှိတာ လုပ်ပြီးမှ ကျွန်တော်တို့ object နဲ့ခေါ်လိုက်တဲ့ method က ထအလုပ်လုပ်တာပါ။ ဒါက constructor ပါ။\n\nDestructor\ndestructor function ရဲ့ keyword က __destruct() ဖြစ်ပြီး ရေးမယ်ဆိုရင် ဒီလိုရေးရပါတယ်။\n\npublic function __destruct(){\n\t// Your code is here\n}\n\ndestructor method ကတော့ constructor ရဲ့ ပြောင်းပြန်ပါ။ နောက်ဆုံးမှာ အလုပ်လုပ်ပါတယ်။ ကျွန်တော်တို့ခေါ်ချင်တဲ့ Class ထဲက method ကို object အနေနဲ့ ခေါ် runရင် ကျွန်တော်တို့ ခေါ်ချင်တဲ့ method အလုပ်လုပ်ပြီးတာနဲ့ ဒီကောင် အလုပ် စလုပ်ပါတယ်။\n\nဆိုတော့ ပြန်ချုပ်ရရင် Constructor ဆိုတာ object ခေါ်ရင် အရင်ဦးဆုံး စလုပ်တဲ့ method ဖြစ်ပြီးတော့ destructor ဆိုတာ နောက်ဆုံးမျ အလုပ်လုပ်တဲ့ method ဖြစ်ပါတယ်။ သိထားရမှာ တစ်ခုက သူတို့ကို ခေါ်အလုပ်လုပ်ဖို့ object ခေါ်ပေးစရာမလိုပါဘူး။ မခေါ်ပဲ သူ့အလိုလို အလုပ်လုပ်တဲ့ method တွေပါ။\n\n"
    },
    {
        "id": 6,
        "title": "Traits in PHP",
        "category_id": 2,
        "photo": "images/6.jpg",
        "description": "PHP မှာ inherit လုပ်ရင် single inheritance ပဲ လုပ်လို့ရပါတယ်။ single inheritance ဆိုတာက child class တစ်ခုက parent class တစ်ခုကိုပဲ inherit လုပ်လို့ရတယ်လို့ ပြောချင်တာပါ။ parent class တစ်ခုထက်ပိုပြီး ခေါ်သုံးချင်တယ်ဆိုရင်တော့ traits class ကိုသုံးရပါမယ်။\n\nTraits Class ထဲမှာ ရိုးရိုး method ကော abstract method တွေပါ အဆင်ပြေတဲ့အပြင် ကြိုက်တဲ့ access modifier ကို အသုံးပြုလို့ရပါတယ်။\n\nအဲ့တော့ traits class ရဲ့ syntax က ဒီလိုမျိူးပါ။\n\ntrait ClassName{\n\t// your code is here\n}\n\nအဲ့ traits class ကို ခေါ်သုံးချင်ရင်တော့ use ဆိုတဲ့ keywords ကို သုံးပေးရမှာပါ။ ဥပမာ အပေါ်က ClassName ဆိုတဲ့ traits ကို ခေါ်သုံးမယ်ဆိုရင် use ClassName ဆိုပြီး သုံးပေးရပါတယ်။ အောက်က ပုံကတော့ Sample Code ပါ။ \n\nMultiple Traits\n\nတစ်ခုထက်ပိုတဲ့ Traits ကို inherit လုပ်ချင်တယ်ဆိုရင်တော့ use ClassName မှာ comma တိုးပြီး ရေးရုံပါပဲ။ အောက်မှာ  Sample Code ပြထားပါတယ်။\n\nအဲ့တော့ Inheritance လုပ်တဲ့နေရာမှာ extends keyword ကိုသုံးမယ်ဆိုရင်တော့ Single Parent Class ကိုပဲ inherit လုပ်လို့ရမှာဖြစ်ပြီး Multiple Parent Class ကို inherit လုပ်ချင်ရင်တော့ Traits ကိုသုံးလို့ရပါကြောင်း...\n\n"
    },
    {
        "id": 7,
        "title": "PHP Autoload",
        "category_id": 2,
        "photo": "images/7.jpg",
        "description": "ကျွန်တော်တို့ PHP OOP အရ Object တွေ Class တွေကို file တွေခွဲပြီး တည်ဆောက်ပြီးပြီ။ ဒါကို ကျွန်တော်တို့ တခြား ဘာမှမရှိတဲ့ php file အသစ်တစ်ခုကနေ ကျွန်တော်တို့ရေးခဲ့တဲ့ Class တွေကို Object ဆောက်ပြီးခေါ်သုံးမယ်ဆိုပါစို့။ သေချာတာတစ်ခုက ကျွန်တော်တို့ Object ခေါ်မဲ့ php file မှာ ဘာမှ မရှိတဲ့အတွက် object ခေါ်သုံးမဲ့ Class ကို require လှမ်းလုပ်ရမှာပါ။ (ဒီ require တွေ include တွေအကြောင်းကိုလဲ articles တစ်ပုဒ်ထပ်တင်ပါ့မယ်။) အဲ့တော့ Class တစ်ခုကို Object ခေါ်ဖို့ အဲ့ PHP Class file ကို require တစ်ခါ လုပ်ရမယ်။ ဒါအဆင်ပြေသေးတယ်။ Class ဆယ်ခုလောက်ဆို အဆင်မပြေတော့ဘူး။ require code က တသီတန်းကြီး ဖြစ်နေရော။ အာ့ကို ရိုးရိုး php file ဆယ်ခုလောက်က ထပ်ခေါ်ရမယ်ဆို ပိုလို့တောင် အဆင်မပြေသေးတယ်။ PHP file တခုမှာ require code ဆယ်ကြောင်းဆို PHP file 10 files လောက်ဆို require code အကြောင်း 100 လောက် လိုက်ရေးနေရမှာ။ အဲ့တော့ ဒီ problem ကိုဖြေရှင်းဖို့ ကျွန်တော်တို့ PHP autoload ဆိုတာကို ခေါ်သုံးရပါတော့မယ်။ ဒီ autoload ရဲ့ သဘောက ဘယ်လိုမျိုးလဲဆိုတာ မရှင်းပြခင် PHP Class တစ်ခုကို Object အနေနဲ့ လှမ်းခေါ်လိုက်တဲ့အခါ ဘယ်လိုအလုပ်လုပ်လဲဆိုတာ အရင်ပြောပြပါမယ်။ ကျွန်တော်တို့ PHP Class တစ်ခုကို Object အနေနဲ့ လှမ်းခေါ်တဲ့အချိန်မှာ new keyword ဆိုတာကို သုံးရပါတယ်။ အဲ့ new keyword ကိုသုံးပြီး Object ခေါ်လိုက်ပြီဆိုတာနဲ့ ကျွန်တော်တို့ခေါ်လိုက်တဲ့ Class က လက်ရှိ php file ထဲမှာ ရှိမရှိ အရင်စစ်ပါတယ်။ ရှိရင် အဲ့ Class ကိုခေါ်သုံးလိုက်ပါတယ်။ မရှိရင် Fatal error: Class not found ဆိုပြီး တက်လာပါတယ်။ ဒါ Object လှမ်းခေါ်ရင် PHP OOP က အလုပ်လုပ်ပုံပါ။ အဲ့အချိန် ကျွန်တော်တို့က autoload ပါ ခေါ်သုံးလိုက်တယ်ဆိုရင် ခုနက Class မရှိခဲ့ရင်ဆိုတဲ့ အဆင့်ကနေ ဆက်သွားပါတယ်။ Class မရှိခဲ့ရင် Autoload ကို သူအလုပ်လုပ်မယ်။ Autoload နဲ့ ကျွန်တော်တို့ခေါ်ထားတဲ့ Class ကို ဆွဲအလုပ်လုပ်မယ်။ အဲ့တာမှ မရှိခဲ့ရင်​တော့ ခုနက Fatal error တက်မှာပါ။ Class not found ပေါ့။ ရှိခဲ့ရင်တော့ Class ကိုလှမ်းခေါ်မှာပါ။ အဲ့တော့ autoload တကယ် ဘယ်လို အလုပ်လုပ်လဲဆိုတာ ရှင်းပြပါမယ်။ \n\nAutoload က require တွေ အများကြီးကို မရေးပါဘူး။ require တစ်ကြောင်းပဲရေးထားတာပါ။ အဲ့တော့ autoload ရေးဖို့အတွက် php file တစ် file အရင်ဆောက်ပါတယ်။ အဲ့ထဲမှာ spl_autoload_register ဆိုတဲ့ autoload method ကိုခေါ်သုံးပါတယ်။ သူ့မှာ callback function ရှိပါတယ်။ အဲ့ callback function ထဲကို ကျွန်တော်တို့ လှမ်းခေါ်လိုက်တဲ့ object class ရဲ့ name က pass လုပ်ပြီး အဲ့ name ကို require ခေါ် run တာပါ။ နားရှုပ်သွားသလား?  Code ပြပါမယ်။\n\nspl_autoload_register(function($classes){\n\treturn require $classes . '.php';\n});\n\nဒါလေးပါပဲ။ အဲ့ file ကို ကျွန်တော်တို့ object ခေါ်သုံးမဲ့ file တိုင်း file တိုင်းရဲ့ ထိပ်ဆုံးမှာ include လုပ်ထားရုံပါပဲ။ require တွေအများကြီးနဲ့ အာရုံနောက်စရာမလိုတော့ပါဘူး။ Class တစ်ခုကို Object လှမ်းခေါ်မယ်။ အဲ့အခါ အဲ့ Class name က spl_autoload_register ထဲကို သူ့ရဲ့ callback function ကနေတဆင့် parameter အနေနဲ့ pass ပါမယ်။ အဲ့ callback function ထဲမှာ ဝင်လာတဲ့ class name ကို require လှမ်းလုပ်ပြီး return ပြန်ပါတယ်။ ဒါပါပဲ။ dynamic ဖြစ်သွားတဲ့အတွက် အများကြီး ရေးစရာမလိုပဲ code သုံးကြောင်းလောက်လေးနဲ့ အလုပ်ဖြစ်သွားတဲ့ autoload ပါ။\n\n"
    },
    {
        "id": 8,
        "title": "Difference between Include, Include Once, Require and Require Once in PHP",
        "category_id": 2,
        "photo": "images/8.jpg",
        "description": "ဒီ article ကတော့ မသိမဖြစ်သိရမယ့် အကြောင်းအရာကို ရေးထားတာပါ။ PHP developer အနေနဲ့ include, include_once, require နဲ့ require_once ဆိုတဲ့ method တွေကို ရင်းနီးမှာပါ။ ဒီလေးခုရဲ့လုပ်ဆောင်ချက်က ကျွန်တော်တို့ လိုအပ်တဲ့ file တွေကို လိုအပ်သလို code ထဲ အစားထိုး ထည့် run ဖို့အတွက် သုံးပါတယ်။ ဥပမာ header.php ဆိုတဲ့ file ကို index.php ဆိုတဲ့ php ထဲမှာ လိုအပ်လို့ ထည့် run မယ်ဆိုရင် header.php ထဲက code တွေကို index.php ထဲ လာမရေးတော့ပဲ အပေါ်က လေးခုထဲက တစ်ခုခုကို index.php ကနေ ခေါ်ပြီး ထည့်ရေးလိုက်တာပါ။ အဲ့တော့ ဒီလေးခုရဲ့ လုပ်ဆောင်ချက်က အတူတူပါပဲ။ ဒါမဲ့ တူရဲ့သားနဲ့ ဘာလို့ လေးခုဖြစ်နေတာလဲဆို မတူတာလေးတွေရှိလို့ပါ။ ဒီမတူတာလေးတွေကို ကျနော် ပြောပြပါမယ်။\n\nအရင်ဆုံး လေးခုထဲက main နှစ်ခု မတူတာကို အရင်ပြောပြပါမယ်။ include နဲ့ require နဲ့ကိုပါ။ \n\ninclude() vs require()\nဥပမာ header.php ကို ကျွန်တော်တိ်ု့ include လုပ်မယ်ဆိုရင် include('header.php'); ဆိုပြီးရေးရပါတယ်။ ဒီလိုရေးလိုက်တာနဲ့ header.php ထဲက code တွေက လာအလုပ်လုပ်ပါတယ်။ (အစားသွင်းလိုက်တာပေါ့) require() လဲ ဒီလိုပါပဲ။ သို့ပေမဲ့ သူတို့မှာမတူတဲ့ အချက်က include လုပ်လို့တဲ့ file မရှိခဲ့ရင် (invalid ဖြစ်ခဲ့ရင်) ဒါမှမဟုတ် တစ်ခုခုကြောင့် error တက်ခဲ့ရင် warning error (E_WARNING) ပဲတက်ပြီး include အောက်မှာ ဆက်ရေးထားတဲ့ code တွေက ဆက်အလုပ်လုပ်ပါတယ်။ require မှာကျ error တက်ရင် fatal error (E_COMPILE_ERROR) တက်ပြီး သူ့အောက်မှာ ဆက်ရေးထားတဲ့ code တွေ အလုပ်မလုပ်တော့ပဲ error တက်တဲ့ require မှာတင် die သွားပါတယ်။\n\ninclude() vs include_once() & require() vs require_once()\nအဲ့တော့ main နစ်ခုရဲ့ differences ကိုသိပြီဆိုရင် သူ့တစ်ခုချင်းဆီမှာ ရှိတဲ့ အရာနှစ်ခုကို နှိုင်းယှဉ်ပြပါမယ်။ include နဲ့ include_once ကော၊ require နဲ့ require_once ကော မတူတဲ့အချက်က file တစ်ခုကို include or require သုံးရင် နောက်ထပ် အဲ့ file ကို include or require ထပ်ရေးရေး ထပ်ခေါ်ပါတယ်။ include_once နဲ့ require_once ကကျတော့ ဘယ်နှစ်ခါခေါ်ခေါ် ခေါ်လိုက်တဲ့ file တူခဲ့ရင် တစ်ခါပဲ ခေါ်ပါတယ်။ ဥပမာ require နဲ့ရှင်းပြပါမယ်။ (include လဲ ထိုနည်း၎င်းပါ)\n\nrequire('header.php');\nrequire('header.php');\n\nအဲ့လိုနှစ်ခါထပ်ရေးရင် header file ကို နှစ်ခါထပ်ခေါ်ပါတယ်။\n\nrequire_once('header.php'):\nrequire_once('header.php'):\n\nrequire_once ကို အဲ့လိုနှစ်ခါထပ်ရေးရင် ခေါ်တဲ့ header file က အတူတူပဲ ဖြစ်တဲ့အတွက် ခုနကလို header file ကို နှစ်ခါထပ်မခေါ်ပဲ တစ်ခါပဲ ခေါ်ပြီး အလုပ်လုပ်ပါတယ်။\n\nဒါဟာ php မှာ မသုံးမဖြစ် သုံးလေ့ရှိတဲ့ include, include_once, require, require_once လေးခုရဲ့ ကွဲပြားခြားနားချက်တွေပါ။\n\n"
    },
    {
        "id": 9,
        "title": "Programming Paradigms",
        "category_id": 3,
        "photo": "images/9.jpg",
        "description": "Programming Paradigms ဆိုတာ ဘာလဲဆိုရင် Programming ရေးနည်း ရေးဟန်ပါပဲ။ Program တစ်ခုဖြစ်ဖို့အတွက် ကျွန်တော်တို့ Code တွေရေးရတယ်။ ရေးပြီဆိုတဲ့နေရာမှာ ရေးဟန်ဆိုတာရှိပါတယ်။ ဘယ်လိုရေးမလဲပေါ့။ Procedural သုံးမှာလား? Object-Oriented နဲ့ရေးမှာလား? Functional နဲ့ ကစ်မှာလား? Logical နဲ့ဖြုတ်မှာလား? အများကြီးပါ။ နားလည်အောင် ပြောရမယ်ဆို English sentence တစ်ခုရေးချင်တယ်ဆိုပါစို့။ ကျွန်တော်တို့ ရေးချင်တဲ့ sentence တစ်ခုရေးဖို့အတွက် ဘာ Grammer သုံးမလဲ? Active <=> Passive လား? Direct <=> Indirect လား? If Clause လား? When Clause လား? ဒါမျိုးပါ။\n\nအဲ့တော့ English စာ တစ်ပုဒ်မှာ ခုနကလို Grammer Pattern များစွာရှိနိုင်သလိုပဲ Programming Language တစ်ခုမှာလဲ Programming Paradigms တွေများစွာရှိနိုင်ပါတယ်။ ဥပမာ Python ဆို Object-Oriented ကော၊ Functional ကော၊ Procedural ကော၊ etc., အကုန်ရပါတယ်။ ကိုယ်ရေးတဲ့ grammer ရဲ့ ရေးနည်းမှန်ဖို့လိုသလို ကိုယ်ရေးတဲ့ programming paradigms ရဲ့ ရေးနည်းလဲမှန်ဖို့လိုပါတယ်။ ဥပမာ procedural နဲ့ object-oriented ရေးရင် imperative မသုံးပဲ declarative သွားသုံးလို့မရသလို၊ functional တွေ logic တွေ mathematical တွေ ရေးမယ်ဆိုရင် declarative မသုံးပဲ imperative သွားသုံးလို့မရပါဘူး။ သူ့ကိုယ်ပိုင်ရေးနည်း ရေးဟန် rules တွေရှိပါတယ်။ procedual နဲ့ object-oriented ဆို imperative style နဲ့ပဲ ရေးလို့ရသလို၊ functional, logic, mathematical တွေ ရေးမယ်ဆိုရင်လဲ declarative style ပဲ သုံးလို့ရမှာပါ။ ဒီမှာ imperative ကော declarative ကော နှစ်ခုစလုံးကလဲ programming paradigms ထဲမှာ ပါဝင်ပါတယ်။ ခုနကပြောပြီးပြီလေ။ programming paradigms တစ်ခုထက်ပိုပြီးရှိနိုင်တယ်လို့။\n\nဒါတွေ ဘာလို့ ကျွန်တော်တို့ သိရမလဲ? \nခုနက ပြောသလို Programming Language တစ်ခုခုသုံးပြီး Code စရေးထဲကိုက ဒီ Programming Paradigms တွေက မသုံးမဖြစ်သုံးနေရတာပါ။ ကိုယ်မသိလို့ပါ။ (မင်းမကြည့်လို့ မသိတာပါ။ အချစ်က မင်းအနားမှာ😂) အဲ့တော့ အနဲဆုံး ကိုယ်စီးတဲ့ မြင်းဟာ အထီးလား အမလား သိအောင် လုပ်ထားသင့်ပါတယ်။ ဒီ့အပြင် programming paradigms တစ်ခုစီမှာလဲ သူ့ရဲ့ အားသာချက် အားနည်းချက်တွေရှိပါတယ်။ ဆိုတော့ ဒီအားသာချက် အားနည်းချက်တွေသိရင် ကိုယ် ဘာလိုချင်ရင် ဘယ်လိုရေးရမလဲဆိုတာ ရွေးချယ်ပြီးအသုံးပြုနိုင်သွားပါပြီ။ ဥပမာ Parallel Computing အတွက်ဆို ငါဘာသုံးမလဲ? Mathematical Computing အတွက်ဆို ဘာသုံးမလဲ? Lazy Evaluation အတွက်ဆို ဘာသုံးမလဲ? execution time မြန်ဖို့အတွက်? side effect နည်းဖို့အတွက်? အစရှိသဖြင့် ကိုယ်လိုချင်တဲ့ main point ကို ထိရောက်အောင် အလွယ်တကူရေးလာနိုင်ပါမယ်။ ဒီလိုရေးလာနိုင်တာနဲ့အမျှ ကိုယ်ရေးလိုက်တဲ့ program ကလဲ error ကင်းကင်း side effect ရှင်းရှင်း memory leak မရှိ ပေါ့ပေါ့ပါးပါးနဲ့ efficient ဖြစ်လာမှာ အသေအချာပါပဲ။\n\nဒီ Programming Paradigms ထဲက Object-Oriented Programming အကြောင်းဖတ်ချင်ရင်တော့ ဒီမှာပါ။ ကျန်တာတွေလဲ ဆက်ရေးသွားပါမယ်။\n\nhttps://www.facebook.com/groups/268145817721147/permalink/342241950311533/\n\nအောက်မှာ Programming Paradigms တွေ သိသလောက်ဖော်ပြပေးထားပါတယ်။\nAction\nAgent-oriented\nArray-oriented\nAutomata-based\nConcurrent computing\nRelativistic programming\nData-driven\nDeclarative (contrast: Imperative)\nFunctional\nFunctional logic\nPurely functional\nLogic\nAbductive logic\nAnswer set\nConcurrent logic\nFunctional logic\nInductive logic\nConstraint\nConstraint logic\nConcurrent constraint logic\nDataflow\nFlow-based\nReactive\nOntology\nDifferentiable\nDynamic/scripting\nEvent-driven\nFunction-level (contrast: Value-level)\nPoint-free style\nConcatenative\nGeneric\nImperative (contrast: Declarative)\nProcedural\nObject-oriented\nPolymorphic\nIntentional\nLanguage-oriented\nDomain-specific\nLiterate\nNatural-language programming\nMetaprogramming\nAutomatic\nInductive programming\nReflective\nAttribute-oriented\nMacro\nTemplate\nNon-structured (contrast: Structured)\nArray\nNondeterministic\nParallel computing\nProcess-oriented\nProbabilistic\nQuantum\nSet-theoretic\nStack-based\nStructured (contrast: Non-structured)\nBlock-structured\nStructured concurrency\nObject-oriented\nActor-based\nClass-based\nConcurrent\nPrototype-based\nBy separation of concerns:\nAspect-oriented\nRole-oriented\nSubject-oriented\nRecursive\nSymbolic\nValue-level (contrast: Function-level)\n"
    },
    {
        "id": 10,
        "title": "Declarative Programming and Imperative Programming",
        "category_id": 3,
        "photo": "images/10.jpg",
        "description": "ဒီ Programming နှစ်ခုဟာ Language တွေမဟုတ်ပါဘူး Paradigms တွေပါ။ Object-Oriented Programming လိုမျိုး programming paradigms တစ်မျိုးပါ။ ဒါကိုဘာလို့ အရင်ပြောပြရလဲဆိုရင် programming paradigms တွေထဲမှာ အခြေခံကျတဲ့ paradigms တစ်မျိုးလို့ ကျွန်တော်မြင်လို့ပါ။ ဘာလို့မြင်လဲဆိုတော့ ရှေ့လျှောက်ပြောပြမဲ့ Procedural Programming နဲ့ ရှေ့မှာပြောပြခဲ့တဲ့ Object-Oriented Programming ဟာ Imperative Programming Style ကို အသုံးပြုရပြီး Functional Programming, Logic Programming နဲ့ Mathematical Issues တွေမှာ Declarative Programming Style ကို အသုံးပြုရလို့ပါ။ ဒါကြောင့် ဒီနှစ်ခုကို အရင်ရှင်းပြတာပါ။\n\nဒီနှစ်ခုရဲ့ သဘောတရားကို နားလည်လွယ်အောင်ပြောရမယ်ဆိုရင် ကောင်မလေးတစ်ယောက်က ကောင်လေးတစ်ယောက်ကို အဖြေပေးတော့မယ်ပေါ့ဗျာ။ အဖြေကလဲ ငြင်းမဲ့အဖြေဗျာ။ အဲ့တော့ ပထမနည်းက ကောင်လေးကို ကောင်မလေးက ပြန်မချစ်နိုင်ဘူးလို့ ဒဲ့တစ်ခွန်းထဲ ပြောချလိုက်ပြီး ငြင်းတာ။ ဒါ နံပါတ် ၁ နည်းလမ်းပေါ့။ နောက်တစ်နည်းကကျ ကောင်မလေးက ကောင်လေးကို ငါနင့်ကို လောလောတယ် စိတ်မဝင်စားသေးဘူး။ ဒါမဲ့ ငါတို့ သူငယ်ချင်းအဆင့်နဲ့ အရင်နေရအောင်။ နေတာကြာလာရင် စိတ်ဝင်စားလာမှာ blah blah blah...။ ဒါလဲငြင်းတာပဲနော် သိဘို့။ သူငြင်းတဲ့နည်းက ငြင်းတဲ့သူအဖိ်ု့ risk များတယ်။ side effect များတယ်။ အငြင်းခံရတဲ့ကောင်လေးက အနားမှာ ရစ်သီရစ်သီနဲ့ ဆက်အာရုံနောက်နေလို့ရတယ်။ :3 အဲ့တော့ ဒီမှာ မတူတာက ပထမနည်းက ပြတ်တယ်။ ရှင်းရှင်းပဲ။ ဒီနည်းက Declarative Programming ။ သူလုပ်ချင်တာကို သူ ပြတ်ပြတ်သားသား ပေမရှည် အမှားမရှိပဲ အလုပ်လုပ်တယ်။ Short to the point ပဲ။ နောက်တစ်နည်းကကျ ပေရှည်တယ်။ ငြင်းတာပဲ အတူတူပဲ။ ဒီနည်းကကျ imperative Programming ။ သူငြင်းရမယ်ဆိုတဲ့ task တစ်ခုကို ပေရှည်ပြီးလုပ်သွားတာ။ လုပ်တာချင်း အတူတူ Declarative Programming နဲ့ Imperative Programming ဘာကွာလဲဆိုတာ မြင်မယ်ထင်တယ်။ Coding နဲ့ ထပ်ပြပါမယ်။\n\nJavaScript နဲ့ ပြပါမယ်။ နားလည်လွယ်အောင်ပါ။\n\nImperative Programming in JavaScript\n\nvar arr = ['a','b','c','d','e'];\nfor(var i = 0; i < 5; i++){\n\tconsole.log(arr[i]);\n}\n\nDeclarative Programming in JavaScript\n\nvar arr = ['a','b','c','d','e'];\narr.map(item => console.log(item));\n\nဒီမှာ ကြည့်မယ်ဆိုရင် Imperative Programming က ရိုးရှင်းပါတယ်။ ကျနော်တို့ array ကို for loop ပတ်ချင်တာပါ။ ဒါကို ပေမရှည်ဘူးလို့ ထင်ကောင်းထင်နိုင်ပါတယ်။ တကယ်တော့ ပေရှည်သလို side effect လဲ များပါတယ်။ for loop ထဲမှာ ထည့်ထားတဲ့ index i က မထည့်တတ်ရင် error တက်တတ်ပါတယ်။ ဒီတော့ ကျွန်တော်တို့ ဒါကို ခပ်ပြတ်ပြတ်ရေးရမယ်ဆိုရင် declarative programming နဲ့ရေးပါမယ်။\n\nဒီ Declarative Programming ကိုကြည့်မယ်ဆိုရင် map function ထည့်ရေးလိုက်တာကို မြင်ရမှာပါ။ အာရုံနောက်စရာ side effect လဲ မရှိပါဘူး။ array မှာ ရှိသလောက် index တွေမကုန်မချင်း သူပတ်ချသွားမယ်။ ဒါပါပဲ။ code လဲ လိုရင်းတိုရှင်းဖြစ်သလို error တက်နိုင်ခြေလဲ နည်းပါတယ်။ ဒါ Imperative Programming နဲ့ Declarative Programming အကြောင်းပါ။ ဒီနည်းလမ်း နှစ်ခုလုံးကို ရေးဖူးမှာပါ။ ဒါမဲ့ Imperative မှန်း Declarative မှန်း အခုမှသိကြတဲ့သူများကိုပြောချင်တာက...\n\nမင်းမကြည့်လို့မသိတာပါ။ အချစ်က မင်းအနားမှာ 😂\n\n"
    },
    {
        "id": 11,
        "title": "Basic Security Thinking (Part-1)",
        "category_id": 4,
        "photo": "images/11.jpg",
        "description": "ဒီတစ်ခေါက် 'Security with PHP' article series ရဲ့ ပထမဆုံး အပိုင်း အနေနဲ့ Security နဲ့ပတ်သက်ပြီး အခြေခံကျတဲ့ thinking တစ်ချို့ကို ဖော်ပြပေးသွားမှာ ဖြစ်ပါတယ်။\n\nPHP နဲ့ပဲဖြစ်ဖြစ် Asp.Net နဲ့ပဲဖြစ်ဖြစ် NodeJs နဲ့ပဲဖြစ်ဖြစ် ဘာ language နဲ့ပဲ ရေးရေး အဓိက အရင်ဆုံး စဉ်းစားရမှာ Security ပါ။ ကိုယ့် project ကြီးလေ Security အပိုင်းကို ပိုပြီး အလေးသာသာ စဉ်းစားရပါမယ်။ မစဉ်းစားပဲ ရေးလိုက်ရင် Hacker တွေက အေးဆေး သာသာယာယာ ကိုယ့်ရဲ့ Data တွေကို ထုတ်ယူလို့ရနိုင်တဲ့အပြင် တချို့ ethic မရှိတဲ့ Black Hat Hacker မျိူးနဲ့တွေ့ရင်တော့ ကိုယ့်ရဲ့ Website or WebApp ကြီးကိုပါ Deface အုပ်ပြီး ဖျက်ချသွားတာမျိုး ကြုံရနိုင်ပါတယ်။ ကိုယ့်ရဲ့ project က သေးသေးလေးပါ ဘာမှ ရေးကြီး ခွင်ကျယ် မရှိပါဘူးဆိုပြီးလဲ Security ပိုင်းကို မစဉ်းစားပဲ နေလို့မရပါဘူး။ လက်အငြိမ်မနေ ခြေအငြိမ်မနေ Script Kiddies (Hacker ပေါက်စ) လေးတွေက သူတိ်ု့ လေ့လာထားတာတွေ ကိုယ်ရည်သွေးဖို့အတွက် ကိ်ုယ့် Website or WebApp က သူတို့အတွက် victim ဖြစ်စေပါတယ်။ ပြီးတော့ အဲ့လို Project အသေးလေးထဲက security ကို ထည့်မစဉ်းစားပဲ ရေးခဲ့ရင် နောင်တချိန် ကိုယ် senior level ဖြစ်လို့ Project အကြီးကြီးတွေ ရေးတဲ့အခါ ဒုက္ခကောင်းကောင်း ရောက်နိုင်ပါတယ်။ ဒီတော့ Security နဲ့ပတ်သက်ပြီး တကယ်ကို အရေးတကြီး ထည့်စဉ်းစားဖို့လိုတယ်ဆိုတာ သိလောက်ပါပြီ။ ဒါဆို Basic Security Thinking တချို့ကို ဆက်လေ့လာကြည့်ရအောင်။\n\n1/ TRUST NOBODY AND NOTHING\nဘယ်သူ့ကိုမှ မယုံပါနဲ့။ အရေးအကြီးဆုံးမို့ ထိပ်ဆုံးမှာ ထားထားတာပါ။ ကျွန်တော့်တို့မှာ ယုံကြည်ရသူဆိုတာ ရှိတတိစမြဲပါပဲ။ သူငယ်ချင်း မိတ်ဆွေ အပေါင်းအသင်း ကိုယ်ယုံကြည်ရာလူတစ်ချို့ကို ကိုယ့်ရဲ့ အားသာချက် အားနည်းချက်တွေ၊ ကိုယ်လုပ်နေတဲ့ အလုပ်အကြောင်းတွေ ပြောပြတတ်စမြဲပါ။ Attacker တွေက ဒီလို ကိုယ်ယုံကြည်ရတဲ့သူတွေကို မသိမသာ ချဉ်းကပ်ပြီး ကိုယ်လုပ်ထားတဲ့ Security Info ကို နှိုက်ယူတတ်သလို၊ Attacker ကိုယ်တိုင်က ကိုယ်ယုံကြည်ရသူ ဖြစ်နေတာမျိုးလဲ ရှိတတ်ပါတယ်။ ဒါကြောင့်မို့ ခြွင်းချက်မရှိ ဘယ်သူ့ကိုမှ ဘယ်အရာကိုမှ မယုံပါနဲ့။\n\n2/ ASSUME A WORSE-CASE SCENARIO\nအဆိုးဝါးဆုံး အခြေအနေအထိ ကြိုတွက်ထားပါ။ ဘယ်လိုပဲ security တွေ အထပ်ထပ်ခံနေပါစေ 'No system is safe' ဆိုတဲ့ စကားကို လက်ကိုင်ထားတဲ့ attacker တွေအတွက်ကတော့ Ez ပါ။ ဒီလိုကြိုတွက်ထားခြင်းအားဖြင့် attacker တွေ attack လုပ်ရင် ဘယ်လောက်ထိ damage ပြင်းမယ် ဘယ်လောက်ထိ ပြင်းထန်ဆုံးရှုံးနိုင်မယ်ဆိုတာကို သိနိုင်မဲ့အပြင် solution ရှာတဲ့ အခါကျရင်လဲ တချို့နေရာတွေကို နဲနဲလေး ပြင်ရုံနဲ့ ရနိုင်မလား? များများပြင်မှ ရမလား? ဒါမှမဟုတ် traditional solution နဲ့ ရနိုင်မလားဆိုတာ ကြိုတင်တွက်ဆ ဆုံးဖြတ်နိုင်ပါတယ်။\n\n3/ APPLY DEFENSE-IN-DEPTH\nထိရောက်တဲ့ ကာကွယ်မှုမျိုး ပြုလုပ်ပါ။ Defense-In-Depth ဆိုတာ စစ်တပ်ကနေ ဆင်းသက်လာတဲ့ စကားလုံးပါ။ စစ်သားတွေက သူတို့ကိုယ်သူတို့ ကာကွယ်ဖို့အတွက် သဲအိတ်တွေ အထပ်ထပ်ကာပြီး wall တွေလုပ်မယ်၊ သံချပ်ကာ or ကျည်ကာတွေ ဝတ်မယ်၊ ယာဉ်ယန္တရားတွေ သုံးမယ် အစရှိတဲ့ ကာကွယ်ရေးပစ္စည်းတွေသုံးကြပါတယ်။ ဒါပေမဲ့ သူတို့ ဘယ်လောက်ပဲ ကာကွယ်ကာကွယ် စုစည်းမှုအား or ထိရောက်တဲ့ defense battle line မရှိပဲ တယောက် တနေရာစီ စစ်ပွဲ ဆင်နွှဲရင်တော့ ဒီကျည်ကာတွေဟာလဲ မကာကွယ်နိုင်ပါဘူး။ ဒီလိုထိရောက်တဲ့ defense battle line နဲ့ စစ်တိုက်ရင်တော့ enemy ဘက်က ဘယ်လောက်အင်အားကြီးနေပါစေ မာထန်ပြီး အင်အားကြီးမားတဲ့ defense ဖြစ်နေမှာ ဖြစ်တဲ့အပြင် enemy ကိုတောင် အနိုင်ယူနိုင်ပါတယ်။ (300 ဇာတ်ကားထဲက Spartan တွေလိုပါပဲ) ဒီတော့ ဒီလို လုံးဝအမှားမခံပဲ ထိရောက်တဲ့ စုစည်းမှုအားပြင်းတဲ့ ကျစ်လျစ်သိပ်သည်းလှတဲ့ defense မျိုးကို ပြုလုပ်ထားရင်တော့ attacker hacker တွေဟာ တော်တော် ဦးနှောက်ခြောက်မဲ့ အခြေအနေမျိုးနဲ့ကြုံတွေ့ရမှာပါ။\n\n4/ KEEP IT SIMPLE STUPID (KISS)\nစောင်ကျိုးနဲအောင် ရိုးရှင်းပါ။😂 ဆိုရိုးတစ်ခုရှိပါတယ်။ အရိုးဆုံးဟာ အဆန်းဆုံးဖြစ်တယ်တဲ့။ ပြီးတော့ သော့ဝိဇ္ဇာကို သော့မခတ်ထားတဲ့ သော့ခလောက်ကို ဖောက်ထွင်းခိုင်းတဲ့ ဖြစ်ရပ်မှန်ကိုလဲ ကြားဖူးကြမှာပါ။ (မကြားဖူးရင် စာရှာဖတ် XD) Defense မှာလဲ ဒီလိုပါပဲ။ အကောင်းဆုံး defense ဆိုတာ ရိုးရိုးရှင်းရှင်းလေးတွေပါ။ ရိုးရိုးရှင်းရှင်းဆိုလို့ ဘာ defense မှ ထည့်မရေးတာမျိူး မဟုတ်ပါဘူး😂 Simple to design, Simple to implement, Simple to understand, simple to use နဲ့ simple to test ပါ။ အကုန် simple ပါ😂 ဘာလို့ဆို ပထမ တစ်ချက်က ရိုးရိုးရှင်းရှင်းလေးပဲ ရေးထားတဲ့အတွက် error တက်နိုင်ချေ အလွန်နည်းပါတယ်။ ဒီလိုနည်းတဲ့အတွက် ယိုပေါက်တွေ ဖြစ်နိုင်ချေ နည်းပါတယ်။ ဒီတော့ security defense အတွက်က အလိုလိုရေးပြီးသားဖြစ်သွားပါတယ်။ ပြီးတော့ attacker တွေဟာ သူတို့ ထိုးဖောက်ဖို့အတွက် logical thinking အကြီးကြီးတွေ အရင်စဉ်းစားမှာပါ။ သေးသေးလေးတွေကို အထင်သေးပြီး လွှတ်ထားတဲ့အတွက် အကြီးကြီးတွေ အလုပ်မဖြစ်ရင် သူတို့ ခေါင်းကိုက်မှာပါ။ (ဒီလိုပြောလို့ Hacker တွေကို အထင်မသေးစေချင်လိုပါ။) ဒီတော့ keep it simple stupid ဘာတဲ့ စောင်ကျိုးနဲအောင် ရိုးရှင်းပါ😂\n\n"
    },
    {
        "id": 12,
        "title": "Basic Security Thinking (Part-2)",
        "category_id": 4,
        "photo": "images/11.jpg",
        "description": "5/ PRINCIPLE OF LEAST PRIVILEGE\nဒါကတော့ Security ရေးတဲ့အခါ သုံးရမဲ့ Theory တစ်ခုပါ။ ဒီ principle က ဘာကိုဆိုလိုတာလဲဆိုတော့ ကိုယ့်ရဲ့ software environment အတွင်းမှာရှိတဲ့ user တွေ program တွေ process တွေ ကို admin ရဲ့ ခွင့်ပြုချက် မလိုပဲ သူ့ဘာသာသူ အလုပ်လုပ်စေတာပါ။ ဥပမာ facebook Group မှာဆို admin ရဲ့ ခွင့်ပြုချက်မလိုပဲ member တစ်ယောက်က post ဝင်တင်တာမျိုးပါ။ ဒီလိုလုပ်ခြင်းအားဖြင့် admin ကို သက်ရောက်မှု အားနည်းသွားမယ်။ admin က အကုန်လုံးကို control လိုက်လုပ်နေရင် attacker က ဘယ်သူက admin ဆိုတာ ရိပ်မိနိုင်သလို အဲ့ admin ကို hack လိ်ုက်တာနဲ့ procedure တခုလုံးကို ရလိုက်သလိုဖြစ်သွားမှာပါ။ ဒီလို မဖြစ်စေချင်လို့ လုပ်ရမဲ့ control process တွေကို သူ့သာသာသူ လုပ်ခွင့်ပေးလိုက်တဲ့အခါ အကယ်၍ admin ကို hack လိုက်တာတောင် တချို့ အပိုင်းတွေကို damage သက်ရောက်မှု နည်းစေသွားနိုင်ပါတယ်။\n\n6/ ATTACKERS CAN SMELL OBSCURITY\nAttacker တွေက ပါးနပ်တယ်။ ဘယ်လိုပါးနပ်တာမျိုးလဲဆိုရင် ကိုယ်​ရေးထားတဲ့ security ကို ခန့်မှန်းပြီး ထိုးဖောက်တာမျိုး။ ဒီ developer ရေးထားတာဆိုရင် သူက ဘယ်လိုရေးနိုင်တယ် ဘယ် step မှာ ဘာခံထားတယ် သူသိတယ်။ အာချောင်တဲ့ developer အများစု ဒီအကွက်ကိုကောင်းကောင်းကြီးမိတယ်။ လေကျယ်တဲ့ developer မျိုးဆို ပြောစရာတောင်မလိုဘူး။ ငါက ဘယ်လိုရေးထားတာ။ ဘာ step တွေခံထားတာ။ ကြိုက်တဲ့ hacker hack စမ်းပါစေ စိန်တောင်ခေါ်လိုက်အုံးမယ် အက်လယ် :3 နောက်နေ့ site ကြီးတက်မလာတော့ရော... အဲ့လိုမျိုးတွေရှိတယ်။ အဲ့တော့ ဒါကို ဖြေရှင်းနိုင်ဖို့ ကိုယ်က ပြန်ပါးနပ်ရတယ်။ Solution ကတော့ Be quite! တိတ်တိတ်နေပါ။ ဒီ project ကိုယ်ရေးထားတာ ဘယ် function တွေသုံးထားတာ ဘယ်လိုတွေရေးထားတာ ဘာညာ အာမချောင်ပါနဲ့။ မေးရင်တောင် ဘူးခံငြင်းပါ။ (ဘူး တစ်လုံးဆောင် အိုတောင်မဆင်းရဲ ဆိုတဲ့ စကားပုံတောင်ရှိတယ်) မသိဘူး။ မဟုတ်ဘူး။ ဘာညာ အဲ့တော့ ဟိုက 'ဒီကောင် အလကားပါကွာ။ ဘာမှမသိဘူး။ လဂျောင် အာပေတူး ငတုံး' ဆိုပြီး ရှောင်သွားပါလိမ့်မယ်။ အပြောခံလိုက်ပါ။ အရှောင်ခံလိုက်ပါ။ ဘေးကင်းပါတယ်။ တကယ့် Hacker ကြီးများကတော့ စိတ်ရှည်ရှည်နဲ့ကိုယ့်ကို စောင့်ကြည့်တတ်ပါတယ်။ မသိသလိုသာ ဘူးခံငြင်းပါ။\n\n7/ RTFM BUT NEVER TRUST IT\nRTFM ဆိုတာ Read the fucking manual ကိုပြောတာပါ။😂 ဆိုလိုချင်တာက manual တွေအကုန်လိုက်ဖတ်ပါ ဒါမဲ့ ဘယ်တော့မှ မယုံပါနဲ့😂။ PHP နဲ့ဆိုင်လို့ PHP ကိုပဲ ပြောပါမယ်။ PHP ရဲ့ official documentation က PHP Manual ဆိုတဲ့ site ပါ။ အဲ့ site က PHP အတွက် Bible လိုပါပဲ။ ဒါပေမဲ့ ဘယ်လိုပဲ PHP documentation ဖြစ်နေပါစေ Stack-overflow လို အကုန်မမှန်တာမျိူးတွေ နားလည်မှုလွဲနေတာမျိုးတွေ error တွေရှိတတ်ပါတယ်။ ဥပမာ ဘယ် function သုံးရင် ဘယ်လိုအားနည်းချက်မျိုး ဖြစ်နိုင်တယ်ဆိုပြီးတော့ ပါချင်မှပါမှာပါ။ Programming Syntax and Semantics တွေအတွက် မှန်ကောင်းမှန်ပေမဲ့ security မှာ ပုံသေကားချပ်မှန်တယ်ဆိုတာမျိုးက မရှိနိုင်ပါဘူး။ အားသာချက် အားနည်းချက်ဆိုတာ ရှိစမြဲပါ။ ဒါကြောင့်မို့လဲ 'No system is safe' ဆိုပြီး ပြောနေကြတာကိုး။ အဲ့တော့ ဆိုလိုချင်တာက ကိုးကွယ်ပါ မရှိခိုးပါနဲ့ဆိုတဲ့အဓိပ္ပါယ်ပါပဲ😂 ဒါဖြင့် ဘယ်သူ့ကိုအဖေခေါ်ရမလဲ😂 Modern Problems အတွက် Modern Solution ရှိပါတယ်။ OWASP - The Open Web Application Security Project ဆိုတဲ့ community ရှိပါတယ်။ (https://owasp.org) ဆိုတဲ့ website မှာ ကို မှီငြမ်းပါ။ သူက လုံးဝ security သီးသန့်အတွက်ပါ။ သူ့ဆီက အကြံဉာဏ်တွေ ယူပါ။ သူက မလုပ်ရင်ကောင်းမယ်ဆိုရင် လုံးဝ မလုပ်ပါနဲ့😂\n\n8/ IF IT WASN'T TESTED, IT DOESN'T WORK\nမစမ်းရသေးသရွေ့ အဲ့ကောင် အလုပ်မလုပ်ပါဘူး။ ဆိုလိုချင်တာကိုသဘောပေါက်လား? အမြဲတမ်း test လုပ်ပါ။ ရေးပြီး သမျှ function process အားလုံးကို တစ်ခုမကျန် testing လိုက်ပါ။ testing လိုက်မှ error တွေ ယိုပေါက်တွေ တွေ့မှာပါ။ ကိုယ်က မစမ်းပဲ ဒီတိုင်း public release လွှတ်ချလိုက်ရော! လက်အငြိမ်မနေ ခြေအငြိမ်မနေ တစ်ကောင်က လျှောက်ကလိလို့ error တွေ့ရင် သူ့အတွက် မဟာ အခွင့်အရေး ဖြစ်သွားမှာပါ။ သေးသေးလေးက အစ ပြန်စစ်ပါ။ ပြန်မစစ်ရသေးတဲ့ ဘယ် function ဘယ် process ကိုပဲ ဖြစ်ဖြစ် စိတ်မချပဲ အလုပ်မလုပ်သေးဘူးလို့သာ မှတ်ယူပါ။\n\n9/ IT'S ALWAYS YOUR FAULT!\nဘယ်သူမပြု မိမိမှုပါပဲ။ ကိုယ်ရေးထားတဲ့ site ပေါက်သွားရင် ကိုယ်စောက်သုံးမကျလို့ပါပဲ။ ဘယ်သူ့မှ လျှောက်အပြစ်လိုက်မတင်ပါနဲ့။ ဘာဆင်ခြေမှလိုက်မပေးပါနဲ့။ တာဝန်ယူမှု တာဝန်ခံမှူဆိုတာရှိပါ။ မသိသေးတာ ရှိရင် သင်ယူပါ လေ့လာပါ။\n\nBasic Security Thinking ဤတွင်ပြီး၏။\n\n"
    },
    {
        "id": 13,
        "title": "Input Validation (How it is danger!)",
        "category_id": 4,
        "photo": "images/13.jpg",
        "description": "PHP Security နဲ့ ပတ်သက်ပြီး ပထမဦးဆုံး ပြင်ဆင်ရမှာက Input Validation ပါ။ Input ဆိုတာ Form Input တွေကို ဆိုလိုတာ ဖြစ်ပြီး Validation ဆိုတာ စစ်ဆေးတာ ဖြစ်ပါတယ်။ Input Validation ဆိုတော့ Form Input က ဝင်ရောက်လာမဲ့ Data တွေကို စစ်ဆေးတာဖြစ်ပါတယ်။ ဘာလို့စစ်ဆေးရသလဲဆိုရင် ဒီ Input တွေဟာ ကိုယ့်ရဲ့ Website or WebApp အတွက် ဂိတ်တံခါးတွေပါပဲ။ Data ပေါင်းစုံ ဝင်ရောက်နိုင်ပါတယ်။ Real Data တွေတင် ဝင်လာမှာ မဟုတ်ပဲ Virus တွေ script တွေလဲ ဒီ Input တွေကနေ ဖြတ်သန်း ဝင်ရောက်လာနိုင်ပါတယ်။ အဲ့ဒီ့အတွက်ကြောင့် WebApp တစ်ခုမှာ Form Validation ကို သေချာ မစစ်ဆေးထားရင် တော်တော်ကြီးကို vulnerabilities များပါတယ်။\n\n- ဘယ်လို အန္တရာယ်ပေးနိုင်သလဲ?\nဥပမာ အားဖြင့် ကျွန်တော်တို့ Form Input ကနေ Username တစ်ခု တောင်းထားတယ်ဆိုပါစို့။ Username Form Input မှာ ဝင်လာမဲ့ Data က Name တွေပဲ ဖြစ်နိုင်မယ်။ Name ဖြစ်တဲ့အတွက် ကျွန်တော်တို့က apostrophes တွေ၊ Commas တွေ၊ Brackets တွေ၊ Spaces တွေ၊ Alphanumeric Unicode တွေ မပါနိုင်လောက်ဘူး ထင်ပြီး အဲ့တာတွေ မစစ်လိုက်ဘူး။ ဟုတ်တယ်မလား။ ကျွန်တော့်နာမည်ဆို Phyoe, Htet'' Kyaw)) ဆိုပြီး ဘယ်တော့မှ အဲ့လို ရိုက်မဖြည့်ဘူးလေ။ Phyoe Htet Kyaw ဒီလိုပဲ ဖြည့်မှာပဲ။ ဒီတော့ ခုနက rules တွေ validate မလုပ်လိုက်ရော! မလုပ်လိုက်တဲ့ အချိန်မှာ ဘာဖြစ်သလဲဆိုတော့ Attacker တစ်ယောက်က အဲ့ Form Input ထဲမှာ SQL Query ကြီး လာထိုးရေးကော! ဥပမာ SELECT * FROM 'user' ဘာညာပေါ့ဗျာ။ အဲ့လိုထိုးရေးရုံနဲ့ ဘာလို့ အန္တရာယ်ရှိနိုင်လဲဆိုရင် အဲ့လို ထိုးရေးတာကိုက Hacking Method တစ်မျိုးဖြစ်တဲ့ SQL Injection နည်းနဲ့ Hack နေတာမို့လို့ပဲ။ (SQL Injection အကြောင်း နောက် articles မှာ အကျယ်တဝင့် ရှင်းပြသွားပါမယ်။)\n\nဒါတင်ပဲလားဆို မဟုတ်သေးဘူး။ html tag တွေ script tag တွေ GET/POST array တွေလိုဟာမျိုးတွေကိုဆို ဘယ်သူမှ ထည့်မယ်လို့ထင်မထားတဲ့အတွက် စစ်ဖို့ရာ ပေါ့လျော့မိမယ်။ အဲ့လိုသာ မစစ်ရင် ခုနက html script tag တွေဟာလဲ XSS attack လို script တွေ virus တွေ အဖြစ် ကိုယ့် WebApp ကို ကောင်းကောင်းကြီး ဒုက္ခပေးနိုင်ပါတယ်။\n\nဒီလောက်ဆို Input Validation ဟာ ဘယ်လောက်အန္တရာယ်များပြီး ပြင်ဆင်ဖို့ ဘယ်လောက် အရေးကြီးလဲ ဆိုတာ သိလောက်ပါပြီ။\n\n"
    },
    {
        "id": 14,
        "title": "Never Blacklist; Only Whitelist",
        "category_id": 4,
        "photo": "images/14.jpg",
        "description": "အရှေ့မှာ ဘယ်လောက် အန္တရာယ်ရှိနိုင်လဲဆိုတာ ပြောပြပြီးနောက်မှာ ဘယ်လို ကာကွယ်မယ်ဆိုတဲ့ အကြောင်းကို စပြောပါတော့မယ်။ အရင်ဆုံး ခေါင်းစဉ်ကတော့ Blacklist ဘယ်တော့မှမလုပ်ပါနဲ့။ Whitelist ပဲ လုပ်ပါလို့ပြောထားတာပါ။\n\nဒီနေရာမှာ Blacklist ကဘာလဲ? Whitelist ကဘာလဲ ရှင်းပြဖို့လိုလာပါပြီ။ ဝင်လာတဲ့ Input တွေကို Validation လုပ်တဲ့နေရာမှာ Blacklisting နဲ့ Whitelisting ဆိုပြီး (၂) မျိုးရှိပါတယ်။ Blacklisting Validation ဆိုတာ Input က ဝင်လာတဲ့ အဆင်မပြေတဲ့ (လက်မခံနိူင်တဲ့) Data တွေကို စစ်ဆေးတာမျိုးကိုခေါ်ပါတယ်။ Whitelisting Validation ဆိုတာကတော့ ကိုယ်လိုချင်တဲ့ (လက်ခံနိုင်တဲ့) Data တွေကိုပဲ စစ်ထုတ်တာမျိုးကို ဆိုလိုပါတယ်။\n\nဥပမာအားဖြင့် အရှေ့မှာ ကျွန်တော်ပြောသွားတဲ့အတိုင်း Input ကနေ Virus တွေ Script tag တွေ ဝင်လာနိုင်ပါတယ်။ ဝင်လာတဲ့ Input Data တွေကို အဲ့ Virus တွေ Script Tag တွေ ဟုတ်မဟုတ် စစ်တာမျိုးကို Blacklisting Validation လို့ခေါ်ပါတယ်။ ဘာလို့ဆို Virus တွေ Script tag တွေကို ကိုယ်မှလက်မခံနိုင်တာ။ အဲ့တာကြောင့် အဲ့ဟာတွေနဲ့ တိုက်စစ်တာကြောင့် ဒီ Validation နည်းကို Blacklisting လို့ခေါ်တာပါ။ Whitelisting ကျတော့ ကိုယ်လိုချင်တဲ့ Data ကို တိုက်စစ်တာပါ။ ဥပမာ Age တောင်းထားတဲ့ Input form မှာ Integer ကိုပဲ စစ်ထားတာမျိူးပါ။ ကိုယ်လိုချင်တာ Age ပဲလေ။ Age ဆိုထဲက Integer ပဲဖြစ်သင့်တာ။ တခြား String တို့၊ Double တို့၊ Float တို့ ဝင်လာရင် လက်မခံပါဘူး။ ဒါမျိုး Validate လုပ်တာကို Whitelisting လုပ်တယ်လို့ခေါ်ပါတယ်။\n\nဒါဆိုဘာလို့ Whitelist ပဲသုံး။ Blacklist မသုံးနဲ့လို့ပြောတာလဲ? အဖြေကရှင်းပါတယ်။ Blacklist သုံးပြီး စစ်တဲ့အခါ ကိုယ်လက်မခံနိုင်တဲ့ မလိုချင်တဲ့ Data မျိုးနဲ့ စစ်ရတာမို့ စစ်ဆေးမဲ့ ပမာဏက အရမ်းများပါတယ်။ ဥပမာ Script tag လိုဟာမျိူးကို စစ်မယ်ဆို SQL Query တွေလဲရှိမယ် တခြား Script တွေလဲ အများကြီးရှိမယ် လိုက်စစ်မယ်ဆို ကုန်တောင်မကုန်တဲ့အပြင် ကျန်ခဲ့တာတွေရှိနိုင်ပါတယ်။ အဲ့စစ်ဆေးဖို့ကျန်ခဲ့တဲ့ အထဲကနေ Validation Pass ဖြစ်သွားနိုင်ပါတယ်။ Whitelist သုံးပြီး စစ်တဲ့အခါကျ ကိုယ်လိုချင်တဲ့ Target Data Type ကိုပဲ စစ်တာ ဖြစ်တဲ့အတွက် တိုက်စစ်ရတဲ့ Data ပမာဏ နည်းတဲ့အပြင် Risk လဲ အလွန်နည်းပါတယ်။ ပိုပြီးလဲ တိကျပါတယ်။\n\nဒါကြောင့်မို့ Blacklist လုံးဝမသုံးပါနဲ့။ Whitelist ပဲသုံးပါလို့ ပြောတာပါ။ သင်တန်းတွေ Tutorial တွေမှာတော့ Whitelist နဲ့ သင်ပြတာများပါတယ်။ ဘယ်သူက Blacklist သုံးမှာလဲလို့တော့ မမေးပါနဲ့ သုံးတဲ့သူရှိလို့ သတိပေးတာပါ။ ဒါဆို ဘာက Blacklist လဲ၊ ဘာက Whitelist လဲဆိုတာသိလောက်မှာပါ။ ပြီးတော့ ဘာလို့ Whitlist က Blacklist ထက် ပိုကောင်းတယ်ဆိုတာလဲ သိပြီလို့ ယုံကြည်ပါတယ်။\n\n"
    },
    {
        "id": 15,
        "title": "Operating System",
        "category_id": 5,
        "photo": "images/15.jpg",
        "description": "Operating System ဆိုတာ computer hardware တွေကို manage လုပ်ပေးတဲ့ software တစ်ခုပါ။ သူက user နဲ့ computer hardware အကြားချိတ်ဆက်ပေးတဲ့ ကြားခံနယ်တစ်ခုလိုဖြစ်ပြီးတော့ application program တွေ အတွက် များစွာ အထောက်အကူပြုပါတယ်။ Operating System တွေကို ကျွန်တော်တို့ နေရာအတော်များများမှာ တွေ့ရတတ်ပါတယ်။ ကားတွေ၊ IOT (Internet of Things) အသုံးပြုထားတဲ့ အိမ်သုံးပစ္စည်းတွေ၊ smart phones တွေ၊ Personal Computer တွေ၊ Enterprise Computer နှင့် cloud computing environment တွေများ အတော်များများတွေ့ရတတ်ပါတယ်။\n\nဒီ mordern computing environment ထဲက operating system ရဲ့ role ကို လေ့လာဖို့အတွက် ပထမဦးဆုံး အနေနဲ့ computer hardware ရဲ့ ဖွဲ့စည်းပုံနဲ့ architecture ကို နားလည်ထားဖို့လိုပါတယ်။ ဒီလို နားလည်ထားဖို့လိုတယ်ဆိုတဲ့ အရာမှာ CPU တွေ၊ memory တွေ၊ I/O devices အကြောင်းတွေနှင့် storage အကြောင်းတွေကို သိထားဖို့လိုအပ်ပါတယ်။ ဘာလို့လဲဆိုတော့ Operating System ရဲ့ အခြေခံအကျဆုံး တာဝန်ကိုက ဒီ resources တွေကို program တွေဆီ ဘယ်လို ခွဲဝေစီမံပေးရမလဲဆိုတာပါပဲ။\n\nပြီးတော့ Operating System ဆိုတာ အရမ်းကြီးမားပြီး ရှုပ်ထွေးတဲ့ အရာတစ်ခုပါ။ ဒါပေမဲ့ ဒီလို ကြီးမားရှုပ်ထွေးတဲ့အရာတစ်ခုကို ရဖို့အတွက် တစ်ပိုင်းစီ တစ်ပိုင်းစီ တည်ဆောက်ထားရပါတယ်။ ဒီလို အပိုင်းလေးတွေဟာ input တွေ output တွေ function တွေကို အလုပ်လုပ်နိုင်တဲ့ သူ့ရဲ့ သက်ဆိုင်ရာ system တစ်ခုအတွက် သေချာပြင်ဆင်ထားတဲ့ အပိုင်းလေးတွေဖြစ်ရပါမယ်။\n\nOperating System အကြောင်းကို အကျယ်တဝံ့ ဆက်မပြောခင် Computer System အကြောင်းကို အရင်ပြောပါမယ်။ Computer System ကို လေးပိုင်း ခွဲခြားနိုင်ပါတယ်။\n\n1) Hardware\n2) Operating System\n3) Application Programs\n4) User\n\nအဲ့လေးခုမှာ တစ်ခုစီကို ပြန်ပြောရရင် \n1) Hardware ဆိုတဲ့ ခေါင်းစဉ်အောက်မှာ CPU လို့ခေါ်တဲ့ Central Processing Unit ပါမယ်၊ memory ပါမယ်၊ I/O device လို့ခေါ်တဲ့ Input/Output Device တွေပါမယ်။ ဒီဟာတွေက system တစ်ခုအတွက် အခြေခံအကျဆုံး computing resources တွေဖြစ်ပါတယ်။\n\nOperating System ကို ခဏကျော်ပြီးပြောလိုက်ပါမယ်။\n\n3) Application Programs ဆိုတာ word pricessors လို၊ spreadsheets တွေလို၊ compilers တွေလို၊ web browsers တွေလိုမျိုးကို ဆိုလိုပါတယ်။ ဒီကောင်တွေကို user တွေက သူတို့ရဲ့ computing problems တွေကို ဖြေရှင်းဖို့အတွက် သုံးကြတာ များပါတယ်။ \n\nတစ်နည်းအားဖြင့် ကျွန်တော်တို့ဟာ ခုနကပြောခဲ့တဲ့ Computer System ကို hardware, software နဲ့ data ဆိုပြီးလဲ သုံးပိုင်း ခွဲလို့ရပါတယ်။ ဒီတော့ operating system ဆိုတာ ဒီ သုံးပိုင်းလုံးကို computer system ရဲ့ operation အပိုင်းမှာ သုံးတဲ့အရာလို့မှတ်ယူလဲရပါတယ်။\n\nဥပမာ အားဖြင့် အစိုးရလိုပါပဲ။ (နိုင်ငံရေး မပါဘူးနော် :3) အကျိုးမရှိတဲ့အလုပ်တွေ သူကိုယ်တိုင်ကိုက မလုပ်ပါဘူး။ အကျိုးရှိတဲ့ အလုပ်တွေချည်း လုပ်ပေးနိ်ုင်တဲ့ program တွေပါဝင်တဲ့ environment တစ်ခု ဖန်တီးပေးလိုက်သလိုပါပဲ။ \n\nဒီ့ထက်ပိုပြီး operating system ရဲ့ role ကို နားလည်ဖို့အတွက် operating system မှာရှိတဲ့ user view နဲ့ system view လို့ခေါ်တဲ့ viewports နစ်ခုအကြောင်းကို သိဖို့လိုပါတယ်။ \n\nနောက်နေ့မှဆက်ရေးပါမယ်။ ဒီနေ့တော့ ဒီလောက်ပါပဲ။ :3\n\n"
    },
    {
        "id": 16,
        "title": "User View & System View",
        "category_id": 5,
        "photo": "images/16.jpg",
        "description": "ဒီတစ်ခေါက် ရှေ့မှာ တန်းလန်းကြီးထားခဲ့တဲ့ Operating System ရဲ့ viewports နှစ်ခုကိုရှင်းပါမယ်။ user view နဲ့ system view ပါ။ Operating System ကို user ဘက်က ကြည့်တဲ့ ရှုထောင့်နဲ့ System ဘက်က ကြည့်တဲ့ ရှုထောင့်ပေါ့။\n\nUser View ကတော့ Computer ရဲ့ Interface ကို user တွေသုံးတဲ့အပေါ်မူတည်ပြီး အမျိုးမျိုးကွဲပြားခြားနားပါတယ်။ ဘာလို့ဆို Computer သုံးတဲ့သူတွေက တချို့က Laptop နဲ့သုံးတယ်။ တချို့က mouse, keyboard နဲ့ monitor ပါတဲ့ PC နဲ့သုံးတယ်။ (ဒီနေရာမှာ PC လို့ပြောရုံနဲ့ mouse, keyboard, monitor ပါတယ်ဆိုတာ သိကြပေမဲ့ I/O device hardware တွေမို့ အဓိက အသားပေးပြီး ထည့်ပြောတာပါ။) ဒီလို သုံးကြတဲ့အတွက် Laptop နဲ့ သုံးသုံး၊ PC နဲ့သုံးသုံး သူ့ထဲမှာ ပါတဲ့ system တွေက သူ့ထဲက resources တွေအကုန်လုံးကို  သုံးတဲ့ user ကိုယ်တိုင် အကုန် ဆွဲသုံးလို့ရအောင် design ဆွဲထားတာပါ။ ဒါကြောင့်မို့ Operating System ရဲ့ ရည်ရွယ်ချက်ကိုက user ရဲ့ အလုပ်ကို တွင်တွင်ကျယ်ကျယ် မြန်မြန်ဆန်ဆန် လုပ်နိုင်အောင်အတွက် ဖြစ်ပါတယ်။ ဒီတော့ များသောအားဖြင့် Operating System ဟာ သုံးရလွယ်ကူအောင်ပဲ design ဆွဲထားတာပါ။ Microsoft ရဲ့ Window လိုပါပဲ။ တစ်ခုတော့ ရှိတာပေါ့။ license လို ပိုက်ဆံပေးပြီး သုံးရရင်တော့ သူ့ operating system အတွက် performance တွေ security တွေက ပိုကောင်းမှာပေါ့။ ပိုက်ဆံမပေးဘဲ ဖရီးကြိတ် ကုန်းဆင်းရင်တော့ ဒီတိုင်း resources တွေကိုပဲ ထိန်းချုပ်ခွင့်ရမှာပေါ့။ :3 (ဒီနေရာမှာ resources ဆိုတာ computer ရဲ့ hardware/ software အကုန်ပါ ပါတယ်။) အောက်မှာတော့ user view အတွက် diagram လေး တစ်ခုထည့်ပေးလိုက်ပါတယ်။\n\nနောက်တစ်ခုရှိတာက ဒီဘက်ခေတ်မှာ user အများစုက ဖုန်းတွေ Tablet တွေသုံးလာကြတယ်။ ဒီ devices တွေက laptop တွေ PC တွေရဲ့ Computer System ကို အစားထိုးပြီး တွင်တွင်ကျယ်ကျယ် သုံးလာကြတယ်။ ပြီးတော့ တစ်ခုရှိတာက ဒီကောင်တွေက cellular တွေ wifi technology တွေနဲ့ network တစ်ခါထဲ ချိတ်ပေးပြီးသား။ ဒီ့အပြင် user က system ကို interact လုပ်တဲ့ ပုံစံလဲ မတူတော့ဘူး။ touch screen တွေနဲ့သုံးမယ်။ touch screen ပေါ်မှာ pressing လုပ်မယ်၊ swiping လုပ်မယ်။ ဒီလို interact လုပ်တာ keyboard တွေ mouse တွေနဲ့တောင် feel မတူတော့ဘူး။ ပြီးတော့ ပိုကြမ်းသွားတာက voice recognition interface တွေပါ ပါလာတယ်။ Apple ရဲ့ Siri လိုမျိုးပေါ့။ (Window မှာလဲ ခုတော့ Cortana ပါလာပါပြီ) ဒါကလဲ တစ်ပိုင်းပေါ့နော်။\n\nနောက်တစ်ခုက user view တောင် မရှိတဲ့ computer တွေရှိသေးတယ်။ (စိတ်ဝင်စားသွားပြီမလား XD) အိမ်သုံး လျှပ်စစ်ပစ္စည်းတွေမှာသုံးတဲ့ embedded computer တွေ ( ဥပမာ password နဲ့ lock တွေ) automobile (ဥပမာ ကား) တွေဟာ user view မရှိတဲ့ computer တွေပါ။ သူတို့မှာ numeric keypads တွေ၊ မီးဖွင့်ထားလား ပိတ်ထားလားဆိုတာ ပြတဲ့ indicator အစရှိတဲ့ function တွေအတွက် operating system ရှိပြီးသားပါ။ ဒါပေမဲ့ ဒီ operating system တွေဟာ user ရဲ့ ခိုင်းစေချက်မပါဘဲ အလုပ်လုပ်ဖို့အတွက် design လုပ်ထားပါ။\n\nSystem View ကတော့ရှင်းပါတယ်။ system ဘက်ကကြည့်ရင် Operating System ဆိုတာ hardware တွေကို ထိန်းချုပ်ထားတဲ့ program တစ်ခုပါပဲ။ ဒီတော့ ဒီမှာက operating system ကို resources allocator (resources တွေကို ခွဲဝေပေးသူ) အဖြစ်နဲ့ မှတ်ယူလို့ရပါတယ်။ သိကြတဲ့အတိုင်းပဲ Computer System မှာက CPU time နဲ့ပတ်သက်တာ၊ memory space, storage space, I/O devices အစရှိတဲ့ resources တွေနဲ့ပတ်သက်တဲ့ ပြဿနာတွေကို ဖြေရှင်းဖို့အတွက် သက်ဆိုင်ရာ သူ့ resources နဲ့သူ ရှိပြီးသားပါ။ အဲ့တော့ ဒီ resources တွေကို ချုပ်ကိုင်တဲ့ manager အဖြစ် သူက အလုပ်လုပ်ပါတယ်။ (ဆရာကြီးပေါ့ဗျာ :3) Resources တွေအတွက် တက်လာတဲ့ များပြားရှုပ်ထွေးလှတဲ့ request တွေကို သူထိပ်တိုက်ရင်ဆိုင်တယ်၊ ပြီးတော့ ဘယ်ပြဿနာကို ဘာresources နဲ့ရှင်းမယ်။ ဘယ် program နဲ့ ဘယ် user တွေအတွက် ဘယ် resources တွေခွဲပေးလိုက်ရင် ဒီပြဿနာ ပြေလည်သွားမယ်၊ \n\nဒီလို operate လုပ်ရင်းနဲ့မှ computer system ကို ပိုပြီး ထိထိရောက်ရောက်နဲ့ အဆင်ပြေပြေထိန်းချုပ်သွားတာပါ။ ဒါကြေကာင့် Operating System လို့ခေါ်တာပါ။ :3\n\n"
    },
    {
        "id": 17,
        "title": "Computer-System Organization",
        "category_id": 5,
        "photo": "images/17.jpg",
        "description": "ရှေ့မှာ ကျွန်တော် ထည့်ထည့်ပြောသွားတဲ့ Computer System ဆိုတဲ့အကြောင်းကို ဒီမှာ ရှင်းပါမယ်။ Computer System မှာ ဘာတွေပါမလဲဆိုရင် CPU တစ်ခု ဒါမှမဟုတ် တစ်ခုထပ်ပိုပြီး ပါနိုင်တယ်၊ ပြီးရင် Bus တွေနဲ့ ချိတ်ဆက်ထားတဲ့ Device Controllers တွေအများကြီးပါမယ်။ ဒီမှာ ပြောစရာက Bus ဆိုတာ ဘာလဲပေါ့? Bus ဆိုတာ နားလည်အောင်ပြောရရင် Component တွေနဲ့ Shared Memory တွေ ကြားက access provide လုပ်ပေးတဲ့ ကြားခံစနစ်တစ်ခုပါပဲ။ ဥပမာ - USB Port တွေကို တာ၀န်ယူထားတဲ့ USB Hub (USB Controller) ဆိုတာရှိမယ်။ USB Controller သည် ခုနက ပြောတဲ့ Device Controller ၊ အဲ့တော့ အဲ့ USB Controller က ဘာနဲ့ သွားချိတ်ဆက်ရလဲဆိုရင် Memory နဲ့ သွားချိတ်ဆက်ရတယ်။ အဲ့လိုချိတ်ဆက်တဲ့ နေရာမှာ ကြားကနေ ဘာက ချိတ်ဆက်ပေးလဲဆိုရင် ခုနက ပြောတဲ့ Bus ဆိုတာက ချိတ်ဆက်ပေးတယ်။ Bus မှာမှ Control Bus တွေ၊ Address Bus တွေ၊ Data Bus တွေထပ်ရှိသေးတယ်။ ဒါတွေပါထပ်ပြောရရင် System Bus Architecture ဆိုပြီး ခေါင်းစဉ်တစ်ခု ထပ်ထွက်လာမယ်။ ထားတော့။ အဲ့တော့ ခုနက စကားကိုပြန်ဆက်ရရင် Device Controller ဆိုတာ ဘာလဲ ရှင်းဖို့ထပ်လိုမယ်။ Device Controller ဆိုတာ သက်မှတ်ထားတဲ့ သက်ဆိုင်ရာ Device တစ်ခုစီကို တာ၀န်ယူလုပ်ဆောင်ပေးတဲ့ Controller တွေကို ပြောတာ။ ဥပမာ - Audio Input/ Output Device တွေအတွက် Audio Device Controller ရှိမယ်။ Graphice Display တွေအတွက် Graphic Device Controller ဆိုတာရှိမယ်။ ခုနက ပြောထားတဲ့ USB Device တွေအတွက် USB Controller ဆိုတာ ရှိမယ်။ ဒါမျိုး။ ဒါပေမဲ့ တစ်ခုရှိတာက Controller အပေါ်မူတည်ပြီးတော့ Device တစ်ခုထက်ပိုပြီး သူက attached လုပ် တာ၀န်ယူနိုင်တယ်။  ဥပမာ - ခုနကပြောတဲ့ USB Device Controller ဆိုရင် USB Port တွေတစ်ခုမက သူလက်ခံနိုင်တယ်။ အလုပ်လုပ်နိုင်တယ်။ ယေဘူယျအားဖြင့်လဲ Computer တစ်လုံးမှာ USB Port က အနည်းဆုံး ၂ ခုရှိတယ်။ ဒါမျိုးကိုပြောတာ။ ပြီးတော့ Device Controller တစ်ခုက Local Buffer Storage တစ်ချို့နဲ့ special-purpose register တစ်ချို့ကိုပါ maintain လုပ်နိုင်တယ်။ အဲ့တော့ ဘာဖြစ်သွားလဲဆိုရင် Device Controller က သူတာ၀န်ယူထားတဲ့ Device နဲ့ သူ maintain လုပ်ထားတဲ့  local buffer storage ကြားမှာ Data အရွှေ့အပြောင်းကိစ္စကိုပါ သူက လုပ်ဆောင်နိုင်လာတယ်။ အဲ့တော့ ဥပမာအားဖြင့် USB Stick ထဲက Data တွေကို PC ထဲထည့်တယ် ထုတ်တယ် ဆိုတဲ့ကိစ္စဆိုတာ ဒီလိုလုပ်တာမျိုးဖြစ်တယ်။\n\nOperating System တစ်ခုမှာ Device Controller တစ်ခုစီအတွက် Device Driver ဆိုတာ ရှိသေးတယ်။ အဲ့ Device Driver တွေက သူ့ရဲ့ Device Controller တွေကို နားလည်ပြီး သက်ဆိုင်ရာ Device တွေကို တူညီတဲ့ Interface တွေနဲ့ Operating System ကအလုပ်လုပ်ပေးနိုင်အောင် ဆောင်ရွက်ပေးတယ်။ ပြီးတော့ CPU နဲ့ Device Controller တွေက parallel execute လုပ်နိုင်ပြီးတော့ Memory Cycle အတွက် တွက်ချက်မှုတွေပါ လုပ်ပေးနိုင်တယ်။\n\nအဲ့တော့ အခုပြောသွားတာ Computer-System Organization ထဲမှာ ဘာတွေပါလဲဆိုတာပဲ ပြောသွားတာ။ ဘယ်လို Operate လုပ်လဲဆိုတဲ့ အကြောင်းတော့ မပါသေးဘူး။ ပြီးရင် Computer-System Architecture ဆိုတာ ထပ်ရှိသေးတယ်။ အရင်ဆုံး Computer-System Organization operate လုပ်တဲ့နေရာမှာ (၃) ပိုင်းရှိတယ်။\n\n1) Interrupts\n2) Storage Structure\n3) I/O structure\n\nဆိုပြီး ရှိတယ်။ တစ်ပိုင်းစီကတော့ အများကြီးပြောရမှာမို့ ဒီနေ့တော့ ဒီလောက်နဲ့ရပ်ပါမယ်။\n\n"
    },
    {
        "id": 18,
        "title": "Introduction to Interrupts",
        "category_id": 5,
        "photo": "images/15.jpg",
        "description": "ရိုးရိုး Computer တစ်လုံးမှာ ရိုးရိုး Operation တစ်ခုလုပ်မယ်လို့ပဲ စဉ်းစားကြည့်မယ်။ ဘာ Operation လဲဆိုတော့ Program တစ်ခုက I/O system တစ်ခုကို အလုပ်လုပ်မယ်ပေါ့။ I/O (Input/ Output) system တစ်ခု အလုပ်လုပ်ဖို့အတွက် ရိုးရိုးရှင်းရှင်း Procedure ကိုစဉ်းစားရင် Input ၀င်မယ်၊ Processing လုပ်မယ်၊ Output ပြန်ထုတ်မယ်ပေါ့။ အဲ့မှာ အသေးစိတ်ပိုပြီး Analyze ထပ်လုပ်ရရင် Input ၀င်တဲ့အပိုင်းမှာ Input တစ်ခု၀င်ဖို့ ဒါမှမဟုတ် ၀င်လာမဲ့ Input ကိုလက်ခံဖို့အတွက် Device Driver ကနေပြီးတော့ အဆင်ပြေတဲ့ device register ကို Device Controller ထဲမှာ အရင်လုပ်ပေးရတယ်။ ပြီးတော့မှ ဒီ Register က ဘာအလုပ်လုပ်လဲဆိုတာ Device Driver ကနေ ဆုံးဖြတ်ရတယ်။ ဥပမာ - Keyboard ကနေ စာလုံးတစ်လုံး ရိုက်တာမျိုး။ Keyboard သည် Device ဖြစ်မယ်။ အဲ့တော့ Keyboard ဆိုတဲ့ Device တစ်ခုကနေ ၀င်လာမဲ့ Input ကိုအလုပ်လုပ်ဖို့အတွက် Keyboard Device Driver ကနေ Keyboard Device Controller ထဲမှာ အဆင်ပြေတဲ့ register တစ်ခု လုပ်ပေးရတယ်။ ပြီးတော့မှ Keyboard Device Driver ကနေ ဒီ Keyboard ဘာ Input ရိုက်ထည့်လဲဆိုတာကို စောင့်ကြည့်ရတယ်။ ဒါမျိုး။ အဲ့တော့ အဲ့လို စောင့်ကြည့်နေရင်း Input တစ်ခု၀င်လာပြီ ဆိုပါစို့။ အဲ့ Input ကို Device Controller က Device ကနေ Local Buffer Storage ကိုပို့ပေးရတယ်။ အဲ့ပို့ဆောင်ချက် တစ်ခုပြီးတိုင်း Device Controller ကနေပြီးတော့ Device Driver ကို Operation ပြီးပါပြီ ဆိုပြီး inform လှမ်းလုပ်တယ်။ ဥပမာ - Keyboard ကနေ Key တစ်ခုရိုက်လိုက်တိုင်း ရိုက်လိုက်တဲ့ Key Input ကို Device Controller က Device (Keyboard) ကနေ Local Buffer Storage ကို တန်းပို့တယ်။ Local Buffer Storage ကိုရောက်ပြီဆိုတာနဲ့ ခုနက ပြောသလို Device Controller ကနေပြီးတော့ Device Driver ကို Operation ပြီးပါပြီ ဆိုပြီး inform လှမ်းလုပ်တယ်။ အဲ့တော့ အဲ့လုပ်ဆောင်ချက်ပြီးပြီဆိုတာနဲ့ တခြားအလုပ်တွေ လုပ်ဖို့အတွက် Device Driver ကနေပြီးတော့ Operating System မှာရှိတဲ့ တခြားအပိုင်းတွေကို လက်လွှဲတယ်။ ဘယ်လိုအလုပ်မျိုးလဲဆိုရင် ဥပမာ - ခုနက Keyboard ကနေ Key တစ်ခုရိုက်တယ်။ Local Buffer Storage ထဲကိုပို့တယ်။ ဒီအထိပဲ သူ့တာ၀န်က။ အဲ့မှာ ၀င်သွားတဲ့ Input Key ကို ပြန်ထုတ်ပြဖို့လိုတယ်။ အဲ့အလုပ်ကိုကျ တခြား Display အပိုင်းတွေ ဘာညာက အလုပ်လုပ်တာ။ Data Transferring နဲ့ဆိုရင်လဲ Success Alert ဘာညာ တက်ပေးဖို့လိုမယ်။ Unsuccess ဖြစ်ရင်လဲ Device Busy ဘာညာ ပြဖို့လိုမယ်။ ဒါမျိုးပေါ့။ ဒါပေမဲ့ အဲ့မှာ မေးစရာရှိတာက Device Controller ကနေပြီးတော့ Device Driver ကို operation ပြီးကြောင်း ဘယ်လို inform လှမ်းလုပ်လဲပေါ့။ အဲ့အပိုင်းက Interrupts အပိုင်းပဲ။"
    },
    {
        "id": 19,
        "title": "Algorithm",
        "category_id": 6,
        "photo": "images/19.jpg",
        "description": "Computer Science ကျောင်းသားတော်တော်များများ ဒါမှမဟုတ် Developer တော်တော်များများ Algorithm ဆိုတဲ့ စကားလုံးကိုကြားဖူးကြမယ် ထင်ပါတယ်။ လက်ရှိ Operating System Blog Series နှင့် PHP Security Blog Series ကို ရေးနေပေမဲ့လို့ တစ်ဖက်ကပြန်တွေးကြည့်တော့လဲ Computer Science Fields ထဲမှာ Programming နှင့်ဆိုင်တဲ့ မသိမဖြစ်သိရမဲ့ နောက်ထပ် Knowledge တစ်ခုလောက် Sharing လုပ်ချင်လို့ Algorithm အကြောင်းကို ထပ်ရေးဖို့ဖြစ်လာတာပါ။ ပြီးတော့ ခုတလော အလုပ်နည်းနည်းပြန်ပါးလာတော့ စာဖတ် စာရေးဖို့ အချိန်ထွက်လာတာနဲ့ နောက်ထပ် Blog Series တစ်ခုထပ်ရေးဖြစ်သွားပါတယ်။\n\nအဲ့တော့ Algorithm ဆိုတာဘာလဲ?\nAlgorithm ဆိုတာ အလုပ်ကောင်းကောင်းလုပ်ပေးနိုင်တဲ့ Computational Procedures (Program) တစ်ခုပါပဲ။ ဘယ်လို အလုပ်ကောင်းကောင်း လုပ်ပေးနိုင်တာမျိုးလဲဆိုရင် တစ်ခု ဒါမှမဟုတ် တစ်ခုထက်ပိုတဲ့ Value တွေကို Input အဖြစ်ယူမယ်။ ပြီးရင် Processing လုပ်မယ်။ ပြီးရင် တစ်ခု ဒါမှမဟုတ် တစ်ခုထက်ပိုတဲ့ Value တွေကို Output အဖြစ်ပြန်ထုတ်မယ်။ ဒါပဲ။ အဲ့တော့ ပြန်ချုပ်ရရင် Input ကနေ Output ကို ပြောင်းလဲပေးတဲ့ Computational Steps Sequence ကို Algorithm လို့ခေါ်တယ်။ ဥပမာ - 1 + 1 = 2; ဒီ statement လေးတစ်ကြောင်းဟာ Algorithm ပဲ။ ဘာလို့လဲ ဆိုရင် 1 က Input ကနေ လာမယ်။ အဲ့တော့ 1 နှစ်လုံးက Input ၊ လိုချင်တဲ့ Input အကုန်ရတဲ့အခါ Processing လုပ်ရတယ်။ Statement အရ ဘာ Processing လုပ်လဲဆိုတော့ ပေါင်းတယ်။ 1 နဲ့ 1 နဲ့ ပေါင်းတဲ့ Process လုပ်လိုက်တဲ့အခါ 2 ဆိုတဲ့ Output ရလာတယ်။ အဲ့တော့ Input စတောင်းတဲ့နေရာကနေ Output ပြန်ထုတ်တဲ့ နေရာအထိ 1 + 1 = 2 ဆိုတဲ့ statement က Algorithm တစ်ခုပဲ။\n\nနောက်တစ်နည်းအားဖြင့် Algorithm ဆိုတာ Computational Problem တွေကို ဖြေရှင်းဖို့အတွက် သုံးတဲ့ Tools အဖြစ်လဲ မှတ်ယူလို့ရတယ်။ ဥပမာ - ကျွန်တော်တို့မှာ Number Sequence တစ်ခုရှိမယ်။ အဲ့ Number Sequence ကို ငယ်စဉ်ကြီးလိုက် (Ascending Order) စီချင်တယ်။ အဲ့တော့ ရှိနေတဲ့ Random Number Sequence က Ascending Order ဖြစ်မနေတော့ အဲ့တာက Computational Problem ဖြစ်မယ်။ ဒါကို Ascending Order စီချလိုက်ရင် ဒီ Problem Solved ဖြစ်သွားမယ်။ အဲ့တော့ လိုချင်တဲ့ Solution ကို ရဖို့အတွက် ဒီ Problem ကို ဘာနဲ့ဖြေရှင်းလဲဆို Tools နဲ့ဖြေရှင်းတယ်။ ဘာ Tools လဲလို့ ထပ်မေးရင် Algorithm ပဲ။ အဲ့တော့ ရှိနေတဲ့ Computational Problem တစ်ခုကို လိုချင်တဲ့ Target Solution ရအောင် Solve လုပ်ပေးတဲ့ tools သည် Algorithm ပဲ။ ခုနက Ascending Order စီတဲ့ problem ကို Sorting Problem လို့ခေါ်ပြီးတော့ Solve ပေးတဲ့ Algorithm ကို Sorting Algorithm လို့ခေါ်တယ်။ နောက်ပိုင်း Algorithm တွေ အများကြီးကို လေ့လာရလိမ့်မယ်။\n\nခုနက Sorting Problem ကိုပဲဆက်ပြောမယ်။ အဲ့တော့ Problem အရ Input မှာ (843, 12, 1, 43, 73, 4, 722, 22) ရှိမယ် ဆိုပါစို့။ အဲ့တော့ ဒီ Sorting Problem ကို Sorting Algorithm နဲ့ ဖြေရှင်းလိုက်ချိန်မှာ Output က (1, 4, 12, 22, 43, 73, 722, 843) ဆိုပြီးထွက်လာမယ်။ ဒီလို Output ထွက်လာဖို့ သုံးလိုက်တဲ့ Sorting Algorithm Formula က ဒီလိုဖြစ်မယ်။ (1 <= 4 <= 12 <= 22 <= 43 <= 73 <= 722 <= 843)။ ( မသိကိန်းနဲ့ သုံးပြီး Formula နဲ့ ရေးပြချင်ပေမဲ့လို့ ရေးရတာ အဆင်မပြေလို့။ ) ဒီ Problem ထဲက Input Sequence ကြီးကို Sorting Problem ရဲ့ Instance ဆိုပြီး ခေါ်တယ်။ အဲ့တော့ ယေဘူယျအားဖြင့် Problem တစ်ခုရဲ့ Instance မှာ ဒီ Problem ကို တွက်ထုတ်ဖြေရှင်းဖို့အတွက် လိုအပ်တဲ့ Input တွေပဲ ပါ၀င်ရမယ်။\n\nအခုပြောသွားတဲ့ Sorting Algorithm ဆိုတာကို Program အများစုမှာ Intermediate Step အနေနဲ့သုံးတယ်။ ပြီးတော့ ဒီ Sorting ဆိုတာ Computer Science မှာ အခြေခံ Operation တစ်ခုအဆင့်ပဲရှိသေးတယ်။ တခြား Sorting Algorithm တွေအများကြီးရှိသေးတယ်။ အဲ့တော့ Sorting Algorithm အများကြီးထဲမှာမှ ဘယ် Sorting Algorithm က ကိုယ်ရေးနေတဲ့ Application အတွက် အကောင်းဆုံးနှင့် အသင့်လျော်ဆုံးဖြစ်မလဲ ဆိုတာ ပြန်စဉ်းစားရတယ်။ ဘာနဲ့တိုင်းတာပြီး စဉ်းစားသလဲဆိုရင် Item (Number) ဘယ်နှခုလောက် sorted လုပ်မှာလဲ? အဲ့ထဲမှာမှ Sort လုပ်ပြီးသား Item (Number) ဘယ်နှခုပါမလဲ? Computer ရဲ့ Architecture က ဘယ်လိုရှိမလဲ? ဘယ်လို Storage Device ကို သုံးမှာလဲ? Main Memory လား? Disks လား? Tapes လား? ဆိုတာ အကုန်လိုက်စဉ်းစားရတယ်။\n\nAlgorithm တစ်ခုဟာ ဘယ်လိုအခြေအနေမှာ မှန်မလဲ?\nProblem ရဲ့ Input Instance တွေအကုန်လုံးကို Execute လုပ်ပြီး မှန်ကန်တဲ့ (ကိုယ်လိုချင်တဲ့) Output ထွက်လာပြီဆိုရင် ဒီ Algorithm တစ်ခုဟာ မှန်ကန်တယ်လို့ ယူဆလို့ရပါတယ်။ ဘာလို့လဲဆိုရင် မှန်ကန်တဲ့ Algorithm တစ်ခုဟာ ပေးထားတဲ့ Computational Problem တစ်ခုကို ကောင်းကောင်းမွန်မွန်ဖြေရှင်းနိုင်ပါတယ်။ မမှန်ကန်တဲ့ Algorithm ကတော့ Input Instance တွေအကုန်လုံးကို Excute လုပ်နိုင်မှာ မဟုတ်ပါဘူး။ မှားရင်မှားတဲ့နေရာမှာ ရပ်ပြီး Error တက်သွားမှာပါ။ အကယ်၍ Input Instance တွေအကုန်လုံးကို Execute လုပ်နိုင်ရင်တောင်မှ မှားနေတဲ့ Output ထွက်လာမှာပါ။ ဒါပေမဲ့လို့ အဲ့ဒီ မှားနေတဲ့ Algorithm တစ်ခုဟာ အသုံးဝင်တဲ့နေရာတော့ ရှိပါတယ်။ Error Rate ကို Control လုပ်တဲ့အချိန်ကျ ဒီ Algorithm အမှားတွေက လိုအပ်ပါတယ်။ ဒါပေမဲ့လို့ အများဆုံးကတော့ Algorithm အမှန်ကိုပဲ ရေးပြီးအသုံးပြုကြရတာပါ။\n\n"
    },
    {
        "id": 20,
        "title": "Introduction to Pseudocode (Part - 1)",
        "category_id": 6,
        "photo": "images/19.jpg",
        "description": "နောက်ပိုင်းမှာ Algorithms အတော်များများကို ဆက်ပြောပြသွားမှာပါ။ အဲ့လိုပြောပြဖို့အတွက် pseudocode ကိုသုံးပြီး ရှင်းပြဖို့လိုအပ်လာပါတယ်။ တစ်ချို့ Algorithms တွေကို ဒီတိုင်းစာရေးပြီး ရှင်းပြလို့ အဆင်ပြေပေမဲ့လို့ တစ်ချို့ဟာတွေကျတော့ Pseudocode လေးနဲ့ရှင်းရင် ပိုပြီး သဘောပေါက် နားလည်လွယ်မယ်ထင်လို့ပါ။ အဲ့တော့ အဲ့အခါကျမှ pseudocode ကို ဂဃနဏ မသိပဲရှင်းပြနေရင် ပိုရှုပ်မှာစိုးလို့ အခုတစ်ခါတည်း pseudocode ကိုအရင်ရှင်းပြတာပါ။\n\nအဲ့တော့ pseudocode ဆိုတာ ဘာလဲ?\nPesudocode ဆိုတာ Computer Program တစ်ခု ဒါမှမဟုတ် Algorithm တစ်ခုရဲ့ အကျယ်ကို နားလည်အောင်ရှင်းပြတဲ့နေရာမှာ အသုံးပြုတဲ့ အရေးအသားပါ။ သူ့ကို ကျွန်တော်တို့က symbolic code တွေနဲ့ရေးပါတယ်။ အဲ့ symbolic code တွေဟာ programming language တွေမဟုတ်ပါဘူး။ သို့ပေမဲ့ အဲ့ symbolic code တွေကို execute မလုပ်ရသေးတဲ့ programming language code တွေအဖြစ် ဘာသာပြန် (translate) လုပ်ရပါတယ်။ အဲ့တော့မှ ဒီ algorithm ရဲ့ pseudocode က ဘာကိုဆိုလိုချင်တာလဲ? ဘယ်လိုအလုပ်လုပ်မှာလဲဆိုတာကို နားလည်မှာြဖစ်ပါတယ်။\n\nAlgorithm တစ်ခုကို ရှင်းလင်းဖော်ပြတဲ့နေရာမှာ pseudocode အပြင် တခြား pseudocode နဲ့အသွင်တူတဲ့အရာတွေကိုလဲ သုံးပါသေးတယ်။ ဥပမာ - Flowchart တို့၊ Drakon-Chart တို့၊ Unified Modified Language (UML) charts တို့ အစရှိတာတွေကိုလဲ အသုံးပြုပါသေးတယ်။ ဒီအကြောင်းတွေကိုလဲ အချိန်ရရင် ကျွန်တော် ပြောပြပေးသွားပါမယ်။\n\nဒါ့ဖြင့် ဒီလိုအများကြီးတွေရှိတဲ့အထဲမှ ဘာလို့ pseudocode ကိုအသုံးပြုတာလဲ?\nProject တစ်ခုမစခင် ဒါမှမဟုတ် Program တစ်ခုမစခင် ကျွန်တော်တို့က Prototype တစ်ခုကိုစီမံရပါတယ်။ Prototype ဆိုတာ ကိုယ်လုပ်မဲ့ real project နဲ့ပုံစံတူ (အစမ်း) တစ်ခုပေါ့။ အဲ့လို Prototype ကို user requirement နှင့်ကိုက်ညီအောင် မျိုးစုံပြင်ဆင် ပြုလုပ်ရပါတယ်။ အဲ့ဒီလိုလုပ်ရင် Prototype တစ်ခုထပ်ပိုပြီး ရှိလာနိုင်ပါတယ်။ အဲ့လို Prototype ပြင်ဆင်မှလဲ Project Management အရ Project အပေါ် Risk သက်ရောက်မှု မရှိသလောက်နည်းပါးမှာဖြစ်ပါတယ်။ နို့မို့ဆို Prototype မပြင်ဆင်ပဲ Real Project တစ်ခါတည်းရေးလိုက်၊ user requirement နှင့်မကိုက်လို့ပြင်လိုက်၊ client မကြိုက်လို့ပြင်လိုက်နဲ့ဆို ဒီ project က ပြင်ရတာများလို့ အနာအဆာများပြီး ရှေ့ရောက်တော့မှာ မဟုတ်ပါဘူး။ ထားပါတော့။ ဒီလို Prototype တွေများများစားစား ပြင်ဆင်ရတဲ့အခါ Algorithm တစ်ခု ဒါမှမဟုတ် Program တစ်ခုကို ကျွန်တော်တို့ ညှိနှုင်းတိုင်ပင်ဆွေးနွေးဖို့အတွက်၊ ညှိနှုင်းတိုင်ပင်ဆွေးနွေးသူတွေနားလည်ဖို့အတွက် programming language code အစား pseudocode တို့ flowchart တို့ကို အသုံးပြုလာပါတယ်။ ဘာလို့ဆို လူတိုင်းနားလည်လွယ်လို့ပါ။ ဥပမာ Developer နှင့် Business Man တို့ Project အကြောင်း ဆွေးနွေးတဲ့အခါ Developer ဘက်ကနေ သူရေးမဲ့ Logic/ Algorithm၊ Flow တွေကို Coding နဲ့ Business Man ကို ရှင်းပြလို့မရပါဘူး။ ဘာလို့ဆို Business Man က Programming Language ရဲ့ Syntax တွေကိုနားမလည်သလို နားလည်အောင်ကြိုးစားဖို့ အတွက်လဲ သူတို့မှာ အချိန်မရှိပါဘူး။ အဲ့တော့ အဲ့အစား pseudocode ဒါမှမဟုတ် flowchart တစ်ခုခုကို အစားထိုးသုံးမယ်ဆိုရင် Developer ဆိုလိုချင်တာကို Business Man က တန်းသဘောပေါက်သလို ဆွေးနွေးရတာလဲ သွက်လာမှာဖြစ်ပါတယ်။ အဲ့တော့ အဲ့ Flowchat နှင့် pseudocode နှစ်ခုထဲမှာမှ ဘာလို့ pseudocode ကိုသုံးလဲပေါ့။ ဘာလို့လဲဆိုရင် flowchart က diagram-based နဲ့သွားတယ်။ algorithm သေးသေးလေးတစ်ခုတောင်မှ ဖော်ပြမဲ့ စာရွက် size အရမ်းယူတယ်။ pseudocode ကျတော့ coding လိုပဲ။ sentence-based နဲ့သွားတာဖြစ်တဲ့အတွက် နေရာအရမ်းမယူသလို programming language ကိုလဲ translate လုပ်ရတာ flowchart ထက်ပိုပြီး အဆင်ပြေတဲ့အတွက် pseudocode ကိုသုံးတာပါ။ (Flowchart ကိုတော့ Project flow description ကို Business Man တွေ Junior Developer/ Programmer တွေပါ နားလည်လွယ်စေချင်တဲ့အတွက် သုံးတာများပြီး pseudocode ကတော့ developer အချင်းချင်း algorithm ဖော်ပြတဲ့အခါ နားလည်လွယ်အောင်ဖော်ပြချင်တဲ့အခါ အသုံးပြုပါတယ်။)\n\npseudocode ရဲ့ statement တွေ syntax တွေကိုတော့ နောက်အပိုင်းမှ ထပ်ရှင်းပြပါမယ်။ အဓိကက pseudocode က ဘာလဲ? ဘာကြောင့်သုံးလဲ? ဘယ်နေရာမှာ သုံးလဲဆိုတာ သိဖို့။ pseudocode ကို မှတ်မိသလောက် Computer Science Major First year မှာ Progrom Development Methodology Paper မှာ သင်တယ်။ သင်ပြီး စာရွက်ပေါ်ချရေး ဘာမှန်းမသိ ညာမှန်းမသိ။ အဓိပ္ပါယ်မရှိ ဆရာမတွေ အပိုလျှောက်ရေးခိုင်းတယ် ထင်မှာစိုးလို့။ :3\n\n"
    },
    {
        "id": 21,
        "title": "Pseudocode Operators & Keywords (Part - 2)",
        "category_id": 6,
        "photo": "images/19.jpg",
        "description": "Pseudocode ရဲ့ အဓိပ္ပာယ်ကို ပြောပြပြီးတဲ့နောက်မှာ သူ့ရဲ့ statement တွေကို အရင်ပြောပါမယ်။ statement တွေထဲမှာမှ Mathematical Operations အပိုင်းကို အရင်ပြောပြပါမယ်။\n\nပထမဆုံး Variable Assign လုပ်တာ။ Programming မှာဆိုရင် Assignment Operator ထဲက equal sign ( = ) လေးပေါ့။ အဲ့ကောင်ကို pseudocode မှာ (←) ဒါမှမဟုတ် (:=) ဆိုပြီး သုံးတယ်။ ဥပမာ - javascript မှာဆို\n\nvar x = 1; ဆိုပါစို့။\n\nအဲ့ကောင်ကို pseudocode မှာရေးရင် ဒီလိုရေးတယ်။\n\nx ← 1 ဒါမှမဟုတ် x := 1 ဆိုပြီးရေးတယ်။ ဒါက Variable ကို Assign လုပ်တာ။\n\nပြီးရင် Comparison Operator တွေဆိုရင်\n\n= (Equal), ≠ (Not Equal), < (Less than), > (Greater than), ≤ (Less than equal), ≥ (Greater than equal) ဒါတွေသုံးမယ်။\n\nArithmetic Operator ဆိုရင်လဲ + (Addition), − (Subtract), × (Mulltiply), / (Divided), mod (Modulus) တွေကိုပဲသုံးတယ်။ ဒီနေရာမှာ mod ကလွဲ ကျန်တာ Programming Syntax နဲ့ အတူတူပဲ။ mod ကကျတော့ အကြွင်းရှာတာ။ Programming Syntax မှာဆို (%) ကိုသုံးတယ်။ ဒီနေရာမှာတော့ (%) အစား mod ကိုပဲသုံးတယ်။ Logical Operator ဆိုရင် AND, OR, NOT သုံးတယ်။ ပြီးတော့ pseudocode မှာ floor/ ceiling ဆိုတာရှိသေးတယ်။ Floor / Ceiling အကြောင်းကတော့ နားလည်အောင်ပြောရရင် Mathematics ဘက်ကနေ လှည့်ပြောဖို့လိုတယ်။ Mathematics မှာ Floor နဲ့ Ceiling function ကတော့ real number တစ်လုံးရဲ့ အနီးစပ်ဆုံး real number တစ်လုံးကိုဆွဲယူတာပဲ။ သူ့ရဲ့ Syntax က ⌊8⌋ (Floor), ⌈10⌉ (Ceiling) ဆိုပြီးသုံးတယ်။ pseudocode မှာလဲ ဒီ syntax ကိုပဲသုံးတယ်။ ဒါဆို syntax နှင့် usage ကိုတော့ သိမယ်ထင်တယ်။ သိပြီဆိုရင် Floor နှင့် Ceiling ကွာခြားပုံကို တစ်ချက်ပြောပြမယ်။ Floor ကကျတော့ real number ရဲ့ အနီးစပ်ဆုံး ငယ်တဲ့ real number ကို ကောက်ယူတာ။ ဥပမာ -\n\n⌊8.6⌋ ဆိုရင် 8 ကို အနီးစပ်ဆုံး real number အငယ်အဖြစ်ယူတာ။\n\ndecimal point ယူတာနဲ့ မတူဘူး။ decimal point ယူတာကျ decimal number က 5 ထက်ကြီးရင် ကိန်းပြည့်ကို 1 တိုးယူတာ။ ဒီမှာက Floor ဆိုရင် သူ့ဘာသူ decimal number က 5 ထက် ဘယ်လောက်ကြီးကြီး အနီးစပ်ဆုံး real number အသေး ကိုပဲယူတာ။ Ceiling ကျတော့ အနီးစပ်ဆုံး real number အကြီးကိုယူတာ။ ဥပမာ -\n\n⌊8.6⌋ ဆိုရင် 9 ကို အနီးစပ်ဆုံး real number အကြီးအဖြစ်ယူတာ။ \n\nအနှုတ်တွေပါလဲဒီတိုင်းပဲ ကိန်းပြည့်ဆိုလဲ ဒီတိုင်းပဲ။ Mathematical terms အရ ပိုသိချင်ရင် အောက်က wiki link မှာ သွားဖတ်လို့ရတယ်။\n\nhttps://en.wikipedia.org/wiki/Floor_and_ceiling_functions\n\nPseudocode မှာ သုံးတဲ့ Operators တွေကို ရှင်းပြပြီးတဲ့နောက်မှာ Pseudocode Keywords တွေကို ထပ်ရှင်းပြမယ်။ ဘယ်လို keywords တွေလဲဆိုရင် -\n\nSTART\nဒီ keyword ကို pseudocode စစရေးချင်းမှာသုံးတယ်။ Program စ run ပြီပေါ့။\n\nINPUT\nဒီ keyword ကိုတော့ user input တောင်းတဲ့နေရာမှာ သုံးတယ်။ ဘယ်လို input တောင်းတောင်းပေါ့။ ဘယ်လို input တောင်းတောင်းဆိုတာက user ကနေ typing ရိုက်ထည့်လိုက်တဲ့ input ဖြစ်စေ၊ input device ကနေ ဝင်လာတဲ့ input ဖြစ်စေ ဘယ်လို input ပဲ ဖြစ်ဖြစ် pseudocode မှာ INPUT keyword ပဲသုံးတယ်။\n\nREAD / GET\nဒီ keywords တွေကို input ကနေ ဝင်လာတဲ့ data တွေကို read လုပ်တဲ့နေရာမှာ သုံးတယ်။\n\nPRINT, DISPLAY, SHOW\nဒီ keywords တွေကို Output ထုတ်ပြတဲ့နေရာမှာ သုံးတယ်။\n\nCOMPUTE, CALCULATE, DETERMINE\nဒီ keywords တွေကိုတော့ Expression တွေမှာ calculate လုပ်တဲ့အခါမှာ သုံးတယ်။\n\nSET, INIT\nဒီ keywords တွေကိုတော့ value တစ်ချို့ကို initialize လုပ်တဲ့အခါမှာ သုံးတယ်။\n\nINCREMENT, BUMP\nဒီ keywords တွေကိုတော့ variable ရဲ့ value တွေကို increment လုပ်တဲ့နေရာမှာ သုံးတယ်။\n\nDECREMENT\nဒီ keyword ကိုတော့ variable ရဲ့ value တွေကို decrement လုပ်တဲ့နေရာမှာ သုံးတယ်။\n\nဒီလောက်ဆိုရင် pseudocode မှာ သုံးတဲ့ syntax အကြမ်းဖျင်းလောက်ကို သိလောက်ပြီထင်တယ်။ ကျန်တဲ့ statement တွေရေးပုံရေးနည်းကိုတော့ ကျန်တဲ့အပိုင်းမှာ ဆက်ပြောသွားပါမယ်။ ခု လက်ရှိ သိထားတဲ့ syntax လောက်နဲ့ program တစ်ခုကို pseudocode နဲ့ ရေးကြည့်မယ်။\n\nSTART\nSET num1, num2, ans\nINPUT num1, num2\nGET num1, num2\nans ← num1 + num2\nPRINT ans\nEND\n"
    }
]