[
    {
        "id": 1,
        "title": "If you want to be a professional web developer",
        "category_id": 1,
        "photo": "images/1.jpg",
        "description": "ခေါင်းစဉ်လေး အတိုင်းပါပဲ။ အကယ်၍ သင်ဟာ professional web developer တစ်ယောက်ဖြစ်ချင်တယ်ဆိုရင်ပေါ့။ ဘာတွေလေ့လာရမလဲ။ ဘယ်လိုလျှောက်လှမ်းရမလဲ ဆိုတာကို ကျွန်တော့်ရဲ့ အတွေ့အကြုံနဲ့ ယှဉ်ပြီးပြောပြသွားမှာပါ။ ပထမဆုံးအနေနဲ့ ဘာတွေလေ့လာရမလဲ။ ဘာတွေလေ့လာရမလဲ ဆိုတာ မပြောခင် Web development ပိုင်းမှာ frontend နဲ့ backend နှစ်ပိုင်းရှိတယ်ဆိုတာ အရင်ပြောပါရစေ။ frontend ဆိုတာ UI (User Interface)/ UX (User Experience) အပိုင်းပါ။ အဓိက အားဖြင့် user တစ်ယောက် မျက်စိနဲ့ မြင်ရမဲ့ design ကို ဖန်တီးရေးဆွဲရတဲ့အပိုင်းပေါ့။ Web Design အပိုင်းလို့လဲ နားလည်ထားလို့ရပါတယ်။ ဒီ Web Design အပိုင်းမှာ ဘာတွေလေ့လာရမလဲဆို Basic နဲ့ Advanced Level နှစ်မျိုး ခွဲပြောပါ့မယ်။ Basic မှာဆို HTML, CSS, Bootstrap, Javascript, JQuery ဒီငါးခုပါ။ skill ကြမ်းနေပြီဆိုရင် ဒီ basic ငါးခုနဲ့တင် Frontend လောကမှာ ဘာဆိုလား လုပ်လို့ရပါတယ်။ တစ်ခုစီရဲ့အကြောင်းကို နောက်ထပ် posts တွေမှာ ထပ်ရှင်းပါမယ်။ ဒီ ငါးခုပြီးရင် Backend ပိုင်းကို ဆက်ပြီး ခြေဆန့်ရမှာပါ။ Frontend Advanced Level မှာ ဘာတွေလေ့လာရမလဲဆိုတော့ SPA (Single Page Application) တွေရေးဖို့အတွက် VueJs, ReactJs, AngularJs ဒါတွေ လက်ကိုင်ထားရပါမယ်။ သုံးခုလုံးမလေ့လာနိုင်ရင်တောင် တစ်ခုလောက်ကတော့ လက်စွဲထားရပါမယ်။ ဒီသုံးခုမှာတောင် next level တွေရှိပါသေးတယ်။ ဒါတွေကိုလဲ နောက်မှပြောပါမယ်။ အဓိက ဒီသုံးခုက Website တစ်ခုကို reload မဖြစ်စေပဲ data binding နဲ့ rendering လုပ်သွားတာပါ။ ဥပမာ facebook ကိုကြည့်ပါ။ ReactJs နဲ့ရေးထားတာပါ။ page reload မရှိဘူး။ မြန်ဆန်တယ်။ Design Rendering ကို လိုသလို စီမံလို့ရတယ်။ ဒါရဲ့ next level တွေဆိုတာက state management တွေ ဘာညာပေါ့။ ဟုတ်ပြီ။ ဒီလိုဆို Backend ပိုင်း ဆက်သွားရအောင်။ ဒီဘက်က နဲနဲပိုကျယ်ပြန့်တယ်ဗျ။ အရင်ဆုံး PHP ကို ဂျွတ်နေအောင် လေ့လာရမယ်။ Procedural (Pure PHP), OOP, MVC အကုန်သိနေရမယ်။ ဒါတွေမပိုင်ပဲ ရှေ့မဆက်စေချင်ဘူး။ ပြီးတော့ MySQL, AJAX, JSON (API)တွေကိုဆက်လေ့လာရမှာပါ။ ပိုင်ပြီဆိုရင်တော့ Laravel ကိုသွားစေချင်တယ်။ Laravel က အခုချိန်မှာ version 8 အထိရောက်နေပြီး PHP God Framework အဖြစ် နေမဝင် အင်ပါယာကို သူနယ်ချဲ့နေတာပါ။ တော်ရုံ ERP solution လောက်ကို laravel နဲ့ကောင်းကောင်းကြီး ကျုံးလို့ရပါတယ်။ livewire ဆိုရင်လဲ VueJs, ReactJs, AngularJs တို့လို SPA ပုံစံပါ။ ဒီ့အပြင် သူ့မှာ နောက်ထပ် package တွေ အများကြီးပါ။ MVC Framework ဖြစ်တဲ့အတွက် ရေးရတာလဲ ခြေမြန်လက်မြန် အတော်ရှိပါတယ်။ တော်တော် အရာရောက်တဲ့ PHP framework ပါ။ ဒီအထိရနေရင်တော့ Professional Web Developer အဖြစ် ကောင်းကောင်း လှုပ်ရှားလို့ရနေပါပြီ။ ဆက်ပြီး လေ့လာချင်ရင်တော့ MEAN Stack (MongoDB, ExpressJs, AngularJs, NodeJs), MERN Stack (MongoDB, ExpressJs, ReactJs, NodeJs) နဲ့ Hybrid Mobile Application Development (VueNative, React Native, Flutter, Ionic) ဘာညာ အများကြီး ဆက်လေ့လာနိုင်ပါတယ်။ ဒီလောက်ဆိုရင်တော့ တော်တော် အဆင်ပြေနေပါပြီ။ ကျန်တာကတော့ ကိုယ့်ရဲ့ လေ့လာအားထုတ်မှု၊ ကြိုးစားမှုနဲ့ skill အပေါ်ပဲ မူတည်ပါတယ်။ "
    },
    {
        "id": 2,
        "title": "Emperor of JavaScript",
        "category_id": 1,
        "photo": "images/2.jpg",
        "description": "Web Development ကို လေ့လာနေတဲ့ မိတ်ဆွေတို့ ဒါမှမဟုတ် Web Developer အဖြစ် လုပ်ကိုင်နေတဲ့ မိတ်ဆွေတို့ JavaScript ဆိုတဲ့ နာမည်ကိုတော့ စိမ်းမယ် မထင်ပါဘူး။ 1995 ခုနှစ်က စတင်တည်ထောင်ခဲ့တဲ့ JavaScript နိုင်ငံတော်ကြီးဟာ NodeJs နန်းတက်လာတဲ့နောက်ပိုင်းမှာ Emperor ကြီးအဖြစ် နယ်ချဲ့ကြီးစိုး အင်အားကြီးလာနေပါပြီ။ NodeJs နန်းမတက်ခင် Vanilla JavaScript လက်ထက်ကတော့ လူတစ်ကာ အနှိမ်ခံ ဘဝနဲ့ Browser ထဲမှာသာကျင်လည်ခဲ့တာပါ။ သူ့ရဲ့ အစွမ်းအစဟာ DOM လုပ်ပိုင်ခွင့်နဲ့ JSlibrary အချို့ကိုသာ ကိုင်တွယ်နိုင်ခဲ့တာ ဖြစ်ပြီး အပြည်ပြည်ဆိုင်ရာ Programming Language နဲ့ Platform အဖွဲ့အစည်းမှာ ဘောင်မဝင် တန်းမဝင် မျက်နှာငယ်ခဲ့ရတာပါ။ ဒါပေမဲ့ 2009 ခုနှစ်မှာ NPM စစ်တပ်နဲ့အတူ နန်းတက်လာခဲ့တဲ့ NodeJs ကတော့ Chrome ရဲ့ V8 engine အကူအညီကိုယူ C++ Programming Language နဲ့ နားလည်မှု MOU ရေးထိုးပြီး platform အနှံ့ နယ်ချဲ့သိမ်းလာတာ ခုဆို Machine Learning ဘက်ကလွဲ ကျန်တာ ကုန်သလောက်ဖြစ်နေပါပြီ။ ရေးလိုက်တဲ့ JavaScript code ကို Chrome V8 engine သုံးပြီး C++ code ပြောင်း၊ C++ compiler နဲ့ run ပြီး လုပ်ချင်တာ လုပ်ခွင့်ရလာတဲ့ NodeJs တစ်ယောက် စပြီး နယ်ချဲ့တာ Server (Backend) ပိုင်းကိုပါပဲ။ ထီးနန်းစည်းစိမ်နဲ့ ယစ်မူးသာယာနေတဲ့ PHP လိုမင်းမျိုးကို Request စောင့်စရာမလိုတဲ့ Server Response လို အကွက်နဲ့အတူ ပေါ့ပါး လျှင်မြန်မှု၊ MVC application pattern ရှိမှု၊ NPM စစ်တပ်ကြီးရဲ့ အားကြီးမှု၊ Security အားသာမှုနဲ့ အခြားသော နည်းပညာ အသစ်အဆန်းတွေနဲ့အတူ အနိုင်ယူပြပါတယ်။ Server (Backend) အပိုင်းကို အပိုင်သိမ်းပြီးတဲ့အခါ PHP မင်းကြီးဟာ ဟက်ကော့ကြီး ကျန်ခဲ့ပြီး သူ့ထီးနန်းကို ပြန်ရဖို့အတွက် Laravel စစ်တပ်ကို တည်ဆောက်ကာ PHP version (8) Beta နဲ့အတူ ပြန်လာနေပါပြီ။ ဒါဟာ JavaScript မင်းနေပြည်ရဲ့ ပထမကျူးကျော်စစ်ပါ။ ပြီးတဲ့အခါ MPA (Multi-Page Application) စနစ်တောက်လျှောက်ကျင့်သုံးလာတဲ့ Web Development ကမ္ဘာမှာ သူ့တိုင်းပြည်အတွက် သူကိုယ်တိုင် စနစ်တစ်ခုကို တပ်မကြီး လေးခုခွဲပြီး တည်ဆောက်ပါတယ်။ SPA (Single-Page Application) လို့ခေါ်တဲ့ စနစ်ကို Ember တပ်၊ Google ရဲ့ Angular တပ်၊ Facebook ရဲ့ React တပ်နဲ့ တရုတ်စစ်သူကြီး Evan You ဦးဆောင်တဲ့ Vue တပ်တို့နဲ့အတူ စတင်တည်ဆောက်ပါတယ်။ Frontend နယ်ပယ်မှာ ကျင်လည်နေတဲ့ Web Development ကမ္ဘာသူ ကမ္ဘာသားတွေအဖို့ လျှင်မြန်သွက်လက်လှတဲ့ ဒီ SPA စနစ်ဟာ သွားရည်ကျစရာဖြစ်လာပါတယ်။ Two-Databinding, State Management, Event Handling, Component Composition တို့နဲ့အတူ Page Reload မဖြစ်တဲ့ အရသာဟာ JavaScript တိုင်းပြည်ရဲ့ အဖိုးတန်ဆုံး ထုန်ကုန်ပါပဲ။ ဒီနည်းနဲ့ SPA နယ်ကို ကိုယ်တိုင်ထူထောင်ပြီး ထပ်နယ်ချဲ့ပါတယ်။ ဒီလိုနဲ့ မပြီးသေးပါဘူး။ အာသာမပြေလှတဲ့ NPM စစ်တပ်ကြီးကို ဦးဆောင်ထားတဲ့ NodeJs ဘုရင်ဟာ JavaScript ကို ပိုမိုအင်အားကြီးအောင် upgrade မြှင့်ပါတယ်။ Facebook အပိုင် React တပ်မကြီးရဲ့ JSX နည်းပညာနဲ့ ECMAscripts တို့ကို အသုံးပြုပြီး JavaScript တိုင်းပြည်ကြီး ယခင်ထက်ပိုတိုးတက်အောင် ဆောင်ရွက်ပါတယ်။ ECMAscripts ဆို JavaScript ကြီး စတည်ထောင်ထဲက နည်းပညာဆိုပေမဲ့လို့ 2015 ခုနှစ် ES5 ကစ နှစ်စဉ် နှစ်စဉ် Upgrade မြှင့်လာရင်း သူတို့ရဲ့ တိုင်းပြည်ကြီးကို ပိုမို တိုးတက်အောင်ဆောင်ရွက်လာပါတယ်။ ဒီ့အပြင် သူတို့က အငြိမ်မနေပဲ Facebook ရဲ့ React တပ်မ ကို အသုံးပြုပြီး Mobile Application Development ဘက်ကို နယ်စချဲ့ပါတယ်။ ပိုမိုအားကောင်းတဲ့ နည်းနဲ့ကို နယ်ချဲ့တာပါ။ Mobile Development မှာ Android နဲ့ IOS ဆိုပြီး နှစ်နိုင်ငံ တင်းမာမှုကို ကြားကနေ ချစ်ကြည်ရေးဝင်ပေးပြီး Hybrid ဆိုတဲ့ နည်းပညာနဲ့ ချုပ်လိုက်ပါတယ်။ ဒါကို React ရဲ့ တပည့် React Native ဆိုတဲ့ တပ်နဲ့အတူ Ionic, Monaca, Vue Native အစရှိတဲ့ တပ်တွေနဲ့ ဝင်တိုက်ပါတယ်။ ဒီတော့ ခဲတစ်လုံးနဲ့ ငှက်နှစ်ကောင်ပစ်သလို Android နဲ့ IOS သီးခြားနှစ်နိုင်ငံကို JavaScript က သိမ်းပိုက်လိုက်ပါတယ်။ PWA (Progressive Web App) ဆိုတဲ့ Standalone web page နည်းပညာကိုလဲ Google ရဲ့ အကူအညီနဲ့အတူ Android ကော IOS ကော နှစ်နိုင်ငံလုံးကို ဆွဲချုပ်ထားပါတယ်။ ဒီလိုနဲ့ Android Development ကလဲ JavaScript ရဲ့ လက်အောက်ခံဖြစ်သွားပါတယ်။ ဒါက JavaScript တို့ရဲ့ ဒုတိယကျူးကျော်စစ်ပါ။ နောက်ဆုံးမှာ JavaScript တို့ ဘယ်လောက်ထိရဲတင်းပြီး အင်အားကြီးလာလဲဆိုရင် Programming Language အဖွဲ့အစည်းရဲ့ အင်အားကြီး နိုင်ငံတွေဖြစ်တဲ့ C++, Java, C#, Python တို့ရဲ့ နယ်မြေအတွင်းရှိတဲ့ Window Form Application အပိုင်းထိပါ ကျူးကျော်ရန်စ လာပါတယ်။ ElectronJs လို့ခေါ်တဲ့ စစ်တပ်နဲ့အတူ စစ်ခင်းတိုက်ယူတာပါ။ တစ်ဆက်ထဲမှာပဲ Game Development 2D 3D ဘက်ကိုလဲ BabylonJs, PixiJs စစ်တပ်ကိုဦးဆောင်ကာ နယ်ချဲ့နေပါတယ်။ ဒါတွေဟာလဲ JavaScript တိုင်းပြည်ရဲ့ တတိယကျူးကျော်စစ်နဲ့ စတုတ္ထကျူးကျော်စစ်ပါ။ ကျူးကျော်စစ်များဆက်တိုက်ဆိုသလို ဆင်နွှဲနေစဉ်အတွင်းမှာပဲ NodeJs ဘုရင်ကြီးဟာ သူ့သားနှစ်ယောက်ကို သူမရှိတော့တဲ့အချိန် JavaScript တိုင်းပြည်ကြီးကို ဒီ့ထက်ပိုကြမ်းအောင် ဆောင်ရွက်နိုင်ဖို့ အိမ်ရှေ့စံရာထူးပေးခဲ့ပါတယ်။ ဒီသားနှစ်ယောက်ကတော့ အဖေ့ရဲ့ ပြုစုသင်ကြားပေးမှုတွေနဲ့ ကြီးပြင်းလာတဲ့ သားကြီး AdonisJs နဲ့ အဖေကို တနေ့ကျ အနိုင်ယူပြမယ်ဆိုပြီး အမြဲကြုံးဝါးနေတဲ့ သားငယ် denoJs ပါပဲ။ ဒီသားနှစ်ယောက် ကျန်ရှိနေတဲ့ Machine Learning နယ်မြေကို ဆက်လက်ကြီးစိုးနိုင်မလားဆိုတာ စောင့်ကြည့်ရမှာပါ။ လောလောဆယ် အဲ့နယ်မြေရဲ့ ရေမြေ့သခင် ပြည့်ရှင်မင်းကတော့ Python မင်းတရားကြီးပါပဲ။ ဆိုတော့ခါ NodeJs ဦးဆောင်တဲ့ NPM စစ်တပ်နဲ့ JavaScript တိုင်းပြည်ကြီးဟာ နေမဝင်ပါယာကြီးကို တည်ထောင်ရင်း သူအမြဲ မိန့်တဲ့ မိန့်ခွန်းတစ်ခုရှိပါတယ်။ အဲ့တာကတော့ 'Everything is JavaScript'."
    },
    {
        "id": 3,
        "title": "Object Oriented Programming (OOP)",
        "category_id": 3,
        "photo": "images/3.jpg",
        "description": "ဘယ် Programming Language ပဲ လေ့လာ လေ့လာ Procedural အဆင့်ပြီးရင် OOP level ကို တက်လှမ်းရ စမြဲပါပဲ။ OOP မသိရင် အကြီးကြီးတွေ ရေးဖို့ အဆင်မပြေလှပါဘူး။ အဲ့တော့ OOP အကြောင်း ကျွန်တော် သိသလောက်ရှင်းပြပါမယ်။\n\nOOP ဆိုတာ Object-Oriented Programming လို့ခေါ်တဲ့ Programming paradim တစ်မျိုးပါ။ Object တွေကို အခြေခံပြီး ရေးသွားတဲ့ paradim ရေးဟန် တစ်မျိုးပါ။\n\nClass တွေ ခွဲပြီး ရေးမယ် ပြန်ချိတ်မယ်။ အဲ့ Class တွေကို Object အဖြစ် ပြန်ခေါ်ပြီး သုံးမယ်။ ဒါမျိုးပါ။ တကယ်တော့ ဒီ့ထက် deep ဖြစ်ပါတယ်။ ဒါက နားလည်လွယ်အောင်ပြောပြတာပါ။\n\nPrinciples of OOP\nOOP လို့ ပြောလိုက်တာနဲ့ OOP ရဲ့ ဒီ အခြေခံ Principles တွေကို သိထားရပါမယ်။ ဒါတွေကတော့\n\nObject\nObject ရဲ့ အဓိပ္ပါယ်က ဘာလဲဆိုရင် အရာဝတ္ထုတိုင်းဟာ Object ပါ။ ဒီတော့ နားမရှုပ်အောင် Programming ကို ဖယ်ပြီး ပြောပါရစေ။ ကျွန်တော်တို့ လက်တွေ့မှာ မြင်နေရတဲ့ အရာဝတ္ထုတွေ အားလုံးဟာ Object ပါ။ ခဲတံ၊ ပေတံ၊ ဘောပင်၊ စာအုပ်၊ ကား၊ လှေ၊ အိမ်၊ လူ ဒါတွေ အားလုံးဟာ  Object ပါ။ အဲ့တော့ programming နဲ့ ပြန်ယှဉ်ရင် Programming မှာ ဘယ်အရာတွေကို Object လို့ခေါ်မလဲ? အရာဝတ္ထုတိုင်းကို object လို့ ခေါ်တဲ့အတွက် variable ဟာ object ပါ။ datatype တွေဟာလဲ object ပါ။ method ဟာလဲ object ပါ။ သေးသေးကြီးကြီး အရာအားလုံးဟာ object ပါ။\n\nClass\nအဲ့တော့ အရာဝတ္ထုတိုင်းဟာ Object ဆိုတာကို နားလည်ရင် အဲ့ object တွေကို စုထားတဲ့ အရာကို class လို့ ခေါ်ပါတယ်။\n\nprogramming ကိုဖယ်ပြီး လက်တွေ့နဲ့ပြောရရင် ခဲတံတွေကို စုထားတဲ့ ကွန်ပါဘူးဆိုရင် ခဲတံဟာ object ဖြစ်ပြီး ကွန်ပါဘူးဟာ Class ဖြစ်ပါမယ်။ ဒီလိုပါပဲ ကားတွေကို စုထားတဲံ ကားပါကင်ဆိုရင် ကားတွေဟာ object ဖြစ်ပြီး ကားပါကင်ဟာ class ဖြစ်ပါမယ်။ ဒီတော့ Programming နဲ့ ပြန်ပြောရရင် Variable တွေ Algorithm တွေ data structure တွေကို စုထားတာ method ဆိုရင် Variable, Algorithm, DataType, DataStructure ဘာညာ အားလုံးဟာ object ဖြစ်ပြီး method ဟာ class ဖြစ်ပါမယ်။ ဒီတော့ method တွေဟာ class ဖြစ်တဲ့ဆိုရင် method တွေကို စုထားတဲ့ file ကို class လို့ခေါ်ပါတယ်။\n\nInheritance\nInheritance က ဘာလဲဆိုတော့ နားလည်အောင်ပြောရရင် လှမ်းချိတ်တာပေါ့။ လက်တွေ့နဲ့ပြောရရင် မိဘနဲ့ သားသမီး ဆက်ဆံရေးလိုမျိုးပေါ့။ သားသမီးကို မိဘက မွေးထုတ်ထားတဲ့အတွက် မိဘဆီကနေ လိုချင်တာတောင်းလို့ရသလိုမျိုး​ပေါ့။ သားသမီးက မိဘကို inheritance လှမ်းလုပ်ထားတဲ့အတွက် ဘာလိုလို မိဘဆီက အဆင်သင့် လက်ဖြန့်တောင်းရုံပဲ။ (ဥပမာနော် ဥပမာ😁😁) အဲ့တော့ programming နဲ့ပြန်ပြောရရင် Class B က Class A ကို inheritance လှမ်းလုပ်မယ်ဆိုပါဆို့။ ဒါဆို Class A က Parent Class ဖြစ်ပြီး Class B က Child Class ဖြစ်သွားမယ်။ အဲ့တော့ Child Class (Class B) က Parent Class (Class A) ထဲကရှိသမျှ objects တွေ (Methods and Variables) တွေအကုန်လုံးကို ခေါ်သုံးလို့ရသွားမယ်။ ဒါ inheritance ရဲ့ သဘောတရားပါ။ inheritance လုပ်တော့မယ်ဆို သူ့ရဲ့ keyword (extends) ဆိုတာကို သုံးရမှာပါ။\n\nPolymorphism\nPolymorphism ဆိုတာ ဘာလဲဆိုရင် အလုပ်တစ်ခုကို မတူညီတဲ့ နည်းလမ်းတွေနဲ့ အလုပ်လုပ်တာကိုပြောတာပါ။ လက်တွေ့နဲ့ယှဉ်ပြီးပြောရရင်တော့ လူတစ်ယောက်က အိမ်မွေးတိရစ္ဆာန် သုံးကောင် မွေးထားတယ်။ ခွေးရယ် ကြောင်ရယ် ဘဲရယ်ပေါ့။ အဲ့တော့ အဲ့လူက သူ့အိမ်မွေး တိရစ္ဆာန်တွေကို စကားပြောစမ်းဆိုတဲ့ task တခုပေးလိုက်မယ်ဆိုပါဆို့။ အဲ့တော့ ခွေးက ဝုတ်ဝုတ်ဆိုပြီးပြောမယ် ကြောင်က ညောင်ညောင် ဆိုပြီးပြောမယ်။ ဘဲက ဂတ်ဂတ် ဆိုပြီးပြောမယ်။ တိရစ္ဆာန်သုံးကောင်က ပြောတဲ့ အသံမတူပေမဲ့ စကားပြောတဲ့ Task ကို အောင်မြင်စွာလုပ်ဆောင်နိုင်တယ်။ ဆိုလိုချင်တာက အလုပ်တစ်ခု လုပ်ခိုင်းလိုက်မယ် အဲ့အလုပ်ကို သင့်လျှော်တဲ့ နည်းလမ်းပေါင်းစုံနဲ့ အလုပ်လုပ်သွားတယ်ပေါ့။ programming နဲ့ယှဉ်ပြီးပြောရရင် polymorphism ကို သုံးပြီးရေးမယ်ဆိုရင် method overloading နဲ့ method overriding ကို သုံးရတယ်။ အဲ့နှစ်ခုရဲ့ သဘောတရားက method name အတူတူပေးထားတယ်။ တောင်းဆိုတဲ့ parameter အရေအတွက် or parameter datatype အမျိုးအစား ကွဲသွားတယ်။ ဥပမာ function A ဆိုတဲ့ method နှစ်ခုရှိမယ်။ ပထမ function A method က parameter နှစ်ခုတောင်းမယ်။ ဒုတိယ function B က parameter သုံးခုတောင်းမယ်ဆိုပါစို့။ အဲ့တော့ object လှမ်းခေါ်ပြီး function A ကို run တော့မယ်ဆိုရင် parameter ထည့်ပေးရတော့မယ်။ ထည့်လိုက်တဲ့ parameter က နှစ်ခုဆိုရင် ပထမ function A method ကို အလုပ်လုပ်ပြီး ထည့်လိုက်တဲ့ parameter သုံးခုဆို ဒုတိယ function B method ကို သွားအလုပ်လုပ်ပါတယ်။ ဒါက polymorphism ပါ။\n\nAbstraction\nAbstraction ကတော့ method တွေကို လျှိ့ဝှက်ရေးပြီး ပြန်သုံးတယ်လို့ မှတ်ယူရင် ရပါတယ်။ ဥပမာအနေနဲ့ လက်တွေ့မှာဆိုရင် ကျွန်တော်တို့ ဖုန်းပြောတယ်။ ဖုန်းပြောဖို့အတွက် ဖုန်းခေါ်တဲ့သူက outcome call က operator ဆီသွားမယ် အဲ့ကတဆင့် ဖုန်းလက်ခံသူဆီ income call ဝင်မယ်။ ကျွန်တော်တို့ ဒီလောက်ပဲ သိထားတာပါ။ သူ့ procedure ကို။ တကယ်က အဲ့ထက်ပိုရှုပ်ထွေးပါတယ်။ အဲ့ရှုပ်ထွေးတဲ့ procedure ကိုလဲ operator က network သမားတွေကလွဲရင် ဘယ်သူမှ ပိုမသိနိုင်ပါဘူး။ ဒီသဘောပါပဲ။ abstraction ကိုသုံးမယ်ဆိုရင် သူ့ရဲ့ keyword ဖြစ်တဲ့ abstract ဆိုတဲ့ keyword ကို class ရဲ့ ရှေ့မှာ ရေးပါတယ်။ (ဥပမာ abstract class A) အဲ့တော့သူ့ကို extends လှမ်းလုပ်တဲ့ class ကနေ method တွေရေးပြီး သူကနေ abstract keyword နဲ့ထိုင်ခေါ်နေရင် method တွေက ဘယ်က အလုပ်လုပ်လို့ လုပ်မှန်းမသိ ဖြစ်သွားပါတယ်။ ဒါက abstraction ပါ။\n\nEncapsulation\nEncapaulation ဆိုတာ ဘာလဲ အရင်မပြောခင် Capsule ဆိုတာ ဘာလဲ အရင်ပြောပါမယ်။ Capsule ရဲ့ အဓိပ္ပါယ်က ဆေးတောင့်ပါ။ ကျွန်တော်တို့နေမကောင်းရင် သောက်နေကျ ဆေးတောင့်လေးတွေကိုပြောတာပါ။ အဲ့ဆေးတောင့်လေးတွေဟာ ဆေးအမှုန့်လေးတွေကို စုထားတာပါ။ အဲ့တော့ အဲ့ဆေးကို သောက်ရင် capsule က အလုပ်မလုပ်ပဲ အဲ့ capsule ထဲက ဆေးမှုန်တွေက အလုပ်လုပ်သွားတာပါ။ ဒီသဘောပါပဲ။ programming မှာ method တွေ အားလုံးကို စုပြီးရေးထားတဲ့ file ကို class လို့ခေါ်ကြောင်းပြောခဲ့ပါတယ်။ အဲ့လို စုပြီးတခုထဲ ရေးထားတာ (Binding) လုပ်ထားတာကို encapsulation လို့ခေါ်ပါတယ်။\n\n"
    },
    {
        "id": 4,
        "title": "Access Modifier in PHP",
        "category_id": 2,
        "photo": "images/4.jpg",
        "description": "<div><font color='#fff'>Access Modifier ဆိုတာ ဘာလဲဆိုရင် နားလည်အောင်ပြောရရင်တော့ ကျွန်တော်တို့ declare လုပ်ထားတဲ့ class တွေ၊ method တွေ၊ variable တွေကို ဘယ်လောက်အတိုင်းအတာအထိ အသုံးပြုခွင့်ပေးမလဲ (Access လုပ်ခွင့်ပေးမလဲ) ဆိုပြီး Modify လုပ်ပေးတဲ့ keyword တွေကို ခေါ်တာပါ။ အဲ့တော့ PHP မှာ ရှိတဲ့ Access Modifier တွေကို လေ့လာကြည့်ရအောင်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Sample Code ကတော့ ဒီလိုမျိုးပါ။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Class Test{</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;protected $name = 'PHP';</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public function returnName(){</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $this-&gt;name;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; public - ကျွန်တော်တို့ဟာ declare လုပ်လိုက်တဲ့ variable ရဲ့ အရှေ့မှာ ဖြစ်ဖြစ် method ရဲ့ အရှေ့မှာ ဖြစ်ဖြစ် public ဆိုတဲ့ Access Modifier ကိုကြေညာလိုက်မယ်ဆိုရင် အဲ့ variable ဒါမှမဟုတ် method ကို project တစ်ခုလုံးရဲ့ ကြိုက်တဲ့နေရာကနေ အချိန်မရွေး လှမ်း access လုပ်လို့ရနိုင်ပါတယ်။ (ခေါ်သုံးလို့ရနိုင်ပါတယ်။)</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; private - ဒီ modifier နဲ့ ကြေညာလိုက်ရင်တော့ ကျွန်တော်တို့ရဲ့ variable ဒါမှမဟုတ် method ကို ကြေညာထားတဲ့ class အတွင်းမှာပဲ သုံးလို့ရပါမယ်။ တခြား ဘယ်နေရာကမှ access လုပ်လို့မရပါဘူး။&nbsp;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; protected - ဒီ modifier လဲ private access modifer လိုပါပဲ။ ကြေညာထားတဲ့ class အတွင်းကပဲ ခေါ်လို့ရပါတယ်။ ဒါပေဲ့ private နဲ့ မတူညီတာက ကြေညာထားတဲ့ Class အတွင်းမှာပဲ သုံးလို့ရတဲ့အပြင် အဲ့ class ကို inheritance (extends) လှမ်းလုပ်ထားတဲ့ class တွေကပါ access လုပ်လို့ရနိုင်မှာဖြစ်ပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; abstract - ဒီ modifier ကတော့ variable တွေကို ကြေညာလို့မရပါဘူး Class နဲ့ method အရှေ့မှာပဲ ကြေညာလို့ရပါတယ်။ အပေါ်က access modifier သုံးခုကတော့ Class တွေရှေ့မှာ ကြေညာလို့မရပါဘူး။ Variable နဲ့ Method အရှေ့မှာပဲ ကြေညာလို့ရတာပါ။ ဘာလို့ဒီ abstract က Class နဲ့ Method အရှေ့မှာပဲ ကြေညာလို့လဲဆိုရင် ဒီ abstract access modifier ဟာ OOP မှာ abstraction ရေးတော့မယ်ဆိုရင် သုံးရတဲ့ အတွက်ကြောင့်ပါ။ ဥပမာ</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; abstract class ParentClass{</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public $name = 'PHP';</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;abstract function saySomething();</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; class ChildClass extends Parent Class{</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public function saySomething(){</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $this-&gt;name . ' is very awesome!';</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; final - ဒီ access modifier ကိုလဲ Class နဲ့ method အရှေ့မှာပဲ ကြေညာလို့ရပါတယ်။ ဒီ access modifier ကိုကြေညာလိုက်ရင် အဲ့ကြေညာခံရတဲ့ Class ဒါမှမဟုတ် method name နဲ့ တူတဲ့ အခြား class ဒါမှမဟုတ် method ရဲ့ override လုပ်ချင်း မခံရတော့ပါဘူး။ ဆိုလိုချင်တာက အဲ့ class or method က unique ဖြစ်သွားပါတယ်။ တခြား class or method ရေးတဲ့အခါ name တူလို့မရတော့ပါဘူး။ Polymorphism နဲ့ လုံးဝဆန့်ကျင်ဘက်ပါ။ Polymorphism မဖြစ်စေချင်ရင် ဒီ modifier ကို သုံးနိုင်ပါတယ်။ အောက်က ဇယားကတော့ ဘယ် access modifier က class, method, variable တွေရှေ့မှာ ကြေညာလို့ရသလဲဆိုတာ ပြထားတာပါ။</font></div>"
    },
    {
        "id": 5,
        "title": "Constructor & Destructor",
        "category_id": 2,
        "photo": "images/5.jpg",
        "description": "<div><font color='#fff'>PHP OOP articles တွေရေးလာတာ ဒါနဲ့ဆို သုံးခုမြောက်ပါ။ ဒီတစ်ခေါက်မှာတော့ PHP OOP မှာပါတဲ့ constructor နဲ့ destructor function အကြောင်းရှင်းပြမှာဖြစ်ပါတယ်။&nbsp;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Constructor</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; constructor function ရဲ့ keyword က __construct() ဖြစ်ပြီး ရေးမယ်ဆိုရင် ဒီလိုရေးရပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; public function __construct(){</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Your code is here</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; constructor function ကို ရေးလိုက်ရင် ဘာဖြစ်သွားမလဲ ဆိုတော့ Class တစ်ခု ကို Object အနေနဲ့ခေါ်လိုက်ပြီဆိုပါစို့။ အဲ့လို Object အနေနဲ့ class ထဲက method တစ်ခုကို ဆွဲခေါ်ရင် အဲ့ခေါ်တဲ့ method ကို အရင်သွား access မလုပ်ပဲ constructor function ကို အရင်ထ run ပါတယ်။ တံခါးမှူးလိုပေါ့။ ဘယ် method ကို object ခေါ် run run သူက အရင်အလုပ်ထလုပ်ပါတယ်။ သူလုပ်စရာရှိတာ လုပ်ပြီးမှ ကျွန်တော်တို့ object နဲ့ခေါ်လိုက်တဲ့ method က ထအလုပ်လုပ်တာပါ။ ဒါက constructor ပါ။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Destructor</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; destructor function ရဲ့ keyword က __destruct() ဖြစ်ပြီး ရေးမယ်ဆိုရင် ဒီလိုရေးရပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; public function __destruct(){</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Your code is here</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; destructor method ကတော့ constructor ရဲ့ ပြောင်းပြန်ပါ။ နောက်ဆုံးမှာ အလုပ်လုပ်ပါတယ်။ ကျွန်တော်တို့ခေါ်ချင်တဲ့ Class ထဲက method ကို object အနေနဲ့ ခေါ် runရင် ကျွန်တော်တို့ ခေါ်ချင်တဲ့ method အလုပ်လုပ်ပြီးတာနဲ့ ဒီကောင် အလုပ် စလုပ်ပါတယ်။&nbsp;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဆိုတော့ ပြန်ချုပ်ရရင် Constructor ဆိုတာ object ခေါ်ရင် အရင်ဦးဆုံး စလုပ်တဲ့ method ဖြစ်ပြီးတော့ destructor ဆိုတာ နောက်ဆုံးမျ အလုပ်လုပ်တဲ့ method ဖြစ်ပါတယ်။ သိထားရမှာ တစ်ခုက သူတို့ကို ခေါ်အလုပ်လုပ်ဖို့ object ခေါ်ပေးစရာမလိုပါဘူး။ မခေါ်ပဲ သူ့အလိုလို အလုပ်လုပ်တဲ့ method တွေပါ။</font></div>"
    },
    {
        "id": 6,
        "title": "Traits in PHP",
        "category_id": 2,
        "photo": "images/6.jpg",
        "description": "<div><font color='#fff'>PHP မှာ inherit လုပ်ရင် single inheritance ပဲ လုပ်လို့ရပါတယ်။ single inheritance ဆိုတာက child class တစ်ခုက parent class တစ်ခုကိုပဲ inherit လုပ်လို့ရတယ်လို့ ပြောချင်တာပါ။ parent class တစ်ခုထက်ပိုပြီး ခေါ်သုံးချင်တယ်ဆိုရင်တော့ traits class ကိုသုံးရပါမယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Traits Class ထဲမှာ ရိုးရိုး method ကော abstract method တွေပါ အဆင်ပြေတဲ့အပြင် ကြိုက်တဲ့ access modifier ကို အသုံးပြုလို့ရပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အဲ့တော့ traits class ရဲ့ syntax က ဒီလိုမျိူးပါ။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; trait ClassName{</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // your code is here</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အဲ့ traits class ကို ခေါ်သုံးချင်ရင်တော့ use ဆိုတဲ့ keywords ကို သုံးပေးရမှာပါ။ ဥပမာ အပေါ်က ClassName ဆိုတဲ့ traits ကို ခေါ်သုံးမယ်ဆိုရင် use ClassName ဆိုပြီး သုံးပေးရပါတယ်။ အောက်က ပုံကတော့ Sample Code ပါ။&nbsp;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Multiple Traits</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; တစ်ခုထက်ပိုတဲ့ Traits ကို inherit လုပ်ချင်တယ်ဆိုရင်တော့ use ClassName မှာ comma တိုးပြီး ရေးရုံပါပဲ။ အောက်မှာ&nbsp; Sample Code ပြထားပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အဲ့တော့ Inheritance လုပ်တဲ့နေရာမှာ extends keyword ကိုသုံးမယ်ဆိုရင်တော့ Single Parent Class ကိုပဲ inherit လုပ်လို့ရမှာဖြစ်ပြီး Multiple Parent Class ကို inherit လုပ်ချင်ရင်တော့ Traits ကိုသုံးလို့ရပါကြောင်း...</font></div>"
    },
    {
        "id": 7,
        "title": "PHP Autoload",
        "category_id": 2,
        "photo": "images/7.jpg",
        "description": "<div><font color='#fff'>ကျွန်တော်တို့ PHP OOP အရ Object တွေ Class တွေကို file တွေခွဲပြီး တည်ဆောက်ပြီးပြီ။ ဒါကို ကျွန်တော်တို့ တခြား ဘာမှမရှိတဲ့ php file အသစ်တစ်ခုကနေ ကျွန်တော်တို့ရေးခဲ့တဲ့ Class တွေကို Object ဆောက်ပြီးခေါ်သုံးမယ်ဆိုပါစို့။ သေချာတာတစ်ခုက ကျွန်တော်တို့ Object ခေါ်မဲ့ php file မှာ ဘာမှ မရှိတဲ့အတွက် object ခေါ်သုံးမဲ့ Class ကို require လှမ်းလုပ်ရမှာပါ။ (ဒီ require တွေ include တွေအကြောင်းကိုလဲ articles တစ်ပုဒ်ထပ်တင်ပါ့မယ်။) အဲ့တော့ Class တစ်ခုကို Object ခေါ်ဖို့ အဲ့ PHP Class file ကို require တစ်ခါ လုပ်ရမယ်။ ဒါအဆင်ပြေသေးတယ်။ Class ဆယ်ခုလောက်ဆို အဆင်မပြေတော့ဘူး။ require code က တသီတန်းကြီး ဖြစ်နေရော။ အာ့ကို ရိုးရိုး php file ဆယ်ခုလောက်က ထပ်ခေါ်ရမယ်ဆို ပိုလို့တောင် အဆင်မပြေသေးတယ်။ PHP file တခုမှာ require code ဆယ်ကြောင်းဆို PHP file 10 files လောက်ဆို require code အကြောင်း 100 လောက် လိုက်ရေးနေရမှာ။ အဲ့တော့ ဒီ problem ကိုဖြေရှင်းဖို့ ကျွန်တော်တို့ PHP autoload ဆိုတာကို ခေါ်သုံးရပါတော့မယ်။ ဒီ autoload ရဲ့ သဘောက ဘယ်လိုမျိုးလဲဆိုတာ မရှင်းပြခင် PHP Class တစ်ခုကို Object အနေနဲ့ လှမ်းခေါ်လိုက်တဲ့အခါ ဘယ်လိုအလုပ်လုပ်လဲဆိုတာ အရင်ပြောပြပါမယ်။ ကျွန်တော်တို့ PHP Class တစ်ခုကို Object အနေနဲ့ လှမ်းခေါ်တဲ့အချိန်မှာ new keyword ဆိုတာကို သုံးရပါတယ်။ အဲ့ new keyword ကိုသုံးပြီး Object ခေါ်လိုက်ပြီဆိုတာနဲ့ ကျွန်တော်တို့ခေါ်လိုက်တဲ့ Class က လက်ရှိ php file ထဲမှာ ရှိမရှိ အရင်စစ်ပါတယ်။ ရှိရင် အဲ့ Class ကိုခေါ်သုံးလိုက်ပါတယ်။ မရှိရင် Fatal error: Class not found ဆိုပြီး တက်လာပါတယ်။ ဒါ Object လှမ်းခေါ်ရင် PHP OOP က အလုပ်လုပ်ပုံပါ။ အဲ့အချိန် ကျွန်တော်တို့က autoload ပါ ခေါ်သုံးလိုက်တယ်ဆိုရင် ခုနက Class မရှိခဲ့ရင်ဆိုတဲ့ အဆင့်ကနေ ဆက်သွားပါတယ်။ Class မရှိခဲ့ရင် Autoload ကို သူအလုပ်လုပ်မယ်။ Autoload နဲ့ ကျွန်တော်တို့ခေါ်ထားတဲ့ Class ကို ဆွဲအလုပ်လုပ်မယ်။ အဲ့တာမှ မရှိခဲ့ရင်​တော့ ခုနက Fatal error တက်မှာပါ။ Class not found ပေါ့။ ရှိခဲ့ရင်တော့ Class ကိုလှမ်းခေါ်မှာပါ။ အဲ့တော့ autoload တကယ် ဘယ်လို အလုပ်လုပ်လဲဆိုတာ ရှင်းပြပါမယ်။&nbsp;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Autoload က require တွေ အများကြီးကို မရေးပါဘူး။ require တစ်ကြောင်းပဲရေးထားတာပါ။ အဲ့တော့ autoload ရေးဖို့အတွက် php file တစ် file အရင်ဆောက်ပါတယ်။ အဲ့ထဲမှာ spl_autoload_register ဆိုတဲ့ autoload method ကိုခေါ်သုံးပါတယ်။ သူ့မှာ callback function ရှိပါတယ်။ အဲ့ callback function ထဲကို ကျွန်တော်တို့ လှမ်းခေါ်လိုက်တဲ့ object class ရဲ့ name က pass လုပ်ပြီး အဲ့ name ကို require ခေါ် run တာပါ။ နားရှုပ်သွားသလား?&nbsp; Code ပြပါမယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; spl_autoload_register(function($classes){</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return require $classes . '.php';</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; });</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဒါလေးပါပဲ။ အဲ့ file ကို ကျွန်တော်တို့ object ခေါ်သုံးမဲ့ file တိုင်း file တိုင်းရဲ့ ထိပ်ဆုံးမှာ include လုပ်ထားရုံပါပဲ။ require တွေအများကြီးနဲ့ အာရုံနောက်စရာမလိုတော့ပါဘူး။ Class တစ်ခုကို Object လှမ်းခေါ်မယ်။ အဲ့အခါ အဲ့ Class name က spl_autoload_register ထဲကို သူ့ရဲ့ callback function ကနေတဆင့် parameter အနေနဲ့ pass ပါမယ်။ အဲ့ callback function ထဲမှာ ဝင်လာတဲ့ class name ကို require လှမ်းလုပ်ပြီး return ပြန်ပါတယ်။ ဒါပါပဲ။ dynamic ဖြစ်သွားတဲ့အတွက် အများကြီး ရေးစရာမလိုပဲ code သုံးကြောင်းလောက်လေးနဲ့ အလုပ်ဖြစ်သွားတဲ့ autoload ပါ။</font></div>"
    },
    {
        "id": 8,
        "title": "Difference between Include, Include Once, Require and Require Once in PHP",
        "category_id": 2,
        "photo": "images/8.jpg",
        "description": "<div><font color='#fff'>ဒီ article ကတော့ မသိမဖြစ်သိရမယ့် အကြောင်းအရာကို ရေးထားတာပါ။ PHP developer အနေနဲ့ include, include_once, require နဲ့ require_once ဆိုတဲ့ method တွေကို ရင်းနီးမှာပါ။ ဒီလေးခုရဲ့လုပ်ဆောင်ချက်က ကျွန်တော်တို့ လိုအပ်တဲ့ file တွေကို လိုအပ်သလို code ထဲ အစားထိုး ထည့် run ဖို့အတွက် သုံးပါတယ်။ ဥပမာ header.php ဆိုတဲ့ file ကို index.php ဆိုတဲ့ php ထဲမှာ လိုအပ်လို့ ထည့် run မယ်ဆိုရင် header.php ထဲက code တွေကို index.php ထဲ လာမရေးတော့ပဲ အပေါ်က လေးခုထဲက တစ်ခုခုကို index.php ကနေ ခေါ်ပြီး ထည့်ရေးလိုက်တာပါ။ အဲ့တော့ ဒီလေးခုရဲ့ လုပ်ဆောင်ချက်က အတူတူပါပဲ။ ဒါမဲ့ တူရဲ့သားနဲ့ ဘာလို့ လေးခုဖြစ်နေတာလဲဆို မတူတာလေးတွေရှိလို့ပါ။ ဒီမတူတာလေးတွေကို ကျနော် ပြောပြပါမယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အရင်ဆုံး လေးခုထဲက main နှစ်ခု မတူတာကို အရင်ပြောပြပါမယ်။ include နဲ့ require နဲ့ကိုပါ။&nbsp;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; include() vs require()</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဥပမာ header.php ကို ကျွန်တော်တိ်ု့ include လုပ်မယ်ဆိုရင် include('header.php'); ဆိုပြီးရေးရပါတယ်။ ဒီလိုရေးလိုက်တာနဲ့ header.php ထဲက code တွေက လာအလုပ်လုပ်ပါတယ်။ (အစားသွင်းလိုက်တာပေါ့) require() လဲ ဒီလိုပါပဲ။ သို့ပေမဲ့ သူတို့မှာမတူတဲ့ အချက်က include လုပ်လို့တဲ့ file မရှိခဲ့ရင် (invalid ဖြစ်ခဲ့ရင်) ဒါမှမဟုတ် တစ်ခုခုကြောင့် error တက်ခဲ့ရင် warning error (E_WARNING) ပဲတက်ပြီး include အောက်မှာ ဆက်ရေးထားတဲ့ code တွေက ဆက်အလုပ်လုပ်ပါတယ်။ require မှာကျ error တက်ရင် fatal error (E_COMPILE_ERROR) တက်ပြီး သူ့အောက်မှာ ဆက်ရေးထားတဲ့ code တွေ အလုပ်မလုပ်တော့ပဲ error တက်တဲ့ require မှာတင် die သွားပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; include() vs include_once() &amp; require() vs require_once()</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အဲ့တော့ main နစ်ခုရဲ့ differences ကိုသိပြီဆိုရင် သူ့တစ်ခုချင်းဆီမှာ ရှိတဲ့ အရာနှစ်ခုကို နှိုင်းယှဉ်ပြပါမယ်။ include နဲ့ include_once ကော၊ require နဲ့ require_once ကော မတူတဲ့အချက်က file တစ်ခုကို include or require သုံးရင် နောက်ထပ် အဲ့ file ကို include or require ထပ်ရေးရေး ထပ်ခေါ်ပါတယ်။ include_once နဲ့ require_once ကကျတော့ ဘယ်နှစ်ခါခေါ်ခေါ် ခေါ်လိုက်တဲ့ file တူခဲ့ရင် တစ်ခါပဲ ခေါ်ပါတယ်။ ဥပမာ require နဲ့ရှင်းပြပါမယ်။ (include လဲ ထိုနည်း၎င်းပါ)</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; require('header.php');</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; require('header.php');</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အဲ့လိုနှစ်ခါထပ်ရေးရင် header file ကို နှစ်ခါထပ်ခေါ်ပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; require_once('header.php'):</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; require_once('header.php'):</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; require_once ကို အဲ့လိုနှစ်ခါထပ်ရေးရင် ခေါ်တဲ့ header file က အတူတူပဲ ဖြစ်တဲ့အတွက် ခုနကလို header file ကို နှစ်ခါထပ်မခေါ်ပဲ တစ်ခါပဲ ခေါ်ပြီး အလုပ်လုပ်ပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဒါဟာ php မှာ မသုံးမဖြစ် သုံးလေ့ရှိတဲ့ include, include_once, require, require_once လေးခုရဲ့ ကွဲပြားခြားနားချက်တွေပါ။</font></div>"
    },
    {
        "id": 9,
        "title": "Programming Paradigms",
        "category_id": 3,
        "photo": "images/9.jpg",
        "description": "<div><font color='#fff'>Programming Paradigms ဆိုတာ ဘာလဲဆိုရင် Programming ရေးနည်း ရေးဟန်ပါပဲ။ Program တစ်ခုဖြစ်ဖို့အတွက် ကျွန်တော်တို့ Code တွေရေးရတယ်။ ရေးပြီဆိုတဲ့နေရာမှာ ရေးဟန်ဆိုတာရှိပါတယ်။ ဘယ်လိုရေးမလဲပေါ့။ Procedural သုံးမှာလား? Object-Oriented နဲ့ရေးမှာလား? Functional နဲ့ ကစ်မှာလား? Logical နဲ့ဖြုတ်မှာလား? အများကြီးပါ။ နားလည်အောင် ပြောရမယ်ဆို English sentence တစ်ခုရေးချင်တယ်ဆိုပါစို့။ ကျွန်တော်တို့ ရေးချင်တဲ့ sentence တစ်ခုရေးဖို့အတွက် ဘာ Grammer သုံးမလဲ? Active &lt;=&gt; Passive လား? Direct &lt;=&gt; Indirect လား? If Clause လား? When Clause လား? ဒါမျိုးပါ။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အဲ့တော့ English စာ တစ်ပုဒ်မှာ ခုနကလို Grammer Pattern များစွာရှိနိုင်သလိုပဲ Programming Language တစ်ခုမှာလဲ Programming Paradigms တွေများစွာရှိနိုင်ပါတယ်။ ဥပမာ Python ဆို Object-Oriented ကော၊ Functional ကော၊ Procedural ကော၊ etc., အကုန်ရပါတယ်။ ကိုယ်ရေးတဲ့ grammer ရဲ့ ရေးနည်းမှန်ဖို့လိုသလို ကိုယ်ရေးတဲ့ programming paradigms ရဲ့ ရေးနည်းလဲမှန်ဖို့လိုပါတယ်။ ဥပမာ procedural နဲ့ object-oriented ရေးရင် imperative မသုံးပဲ declarative သွားသုံးလို့မရသလို၊ functional တွေ logic တွေ mathematical တွေ ရေးမယ်ဆိုရင် declarative မသုံးပဲ imperative သွားသုံးလို့မရပါဘူး။ သူ့ကိုယ်ပိုင်ရေးနည်း ရေးဟန် rules တွေရှိပါတယ်။ procedual နဲ့ object-oriented ဆို imperative style နဲ့ပဲ ရေးလို့ရသလို၊ functional, logic, mathematical တွေ ရေးမယ်ဆိုရင်လဲ declarative style ပဲ သုံးလို့ရမှာပါ။ ဒီမှာ imperative ကော declarative ကော နှစ်ခုစလုံးကလဲ programming paradigms ထဲမှာ ပါဝင်ပါတယ်။ ခုနကပြောပြီးပြီလေ။ programming paradigms တစ်ခုထက်ပိုပြီးရှိနိုင်တယ်လို့။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဒါတွေ ဘာလို့ ကျွန်တော်တို့ သိရမလဲ?&nbsp;</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ခုနက ပြောသလို Programming Language တစ်ခုခုသုံးပြီး Code စရေးထဲကိုက ဒီ Programming Paradigms တွေက မသုံးမဖြစ်သုံးနေရတာပါ။ ကိုယ်မသိလို့ပါ။ (မင်းမကြည့်လို့ မသိတာပါ။ အချစ်က မင်းအနားမှာ😂) အဲ့တော့ အနဲဆုံး ကိုယ်စီးတဲ့ မြင်းဟာ အထီးလား အမလား သိအောင် လုပ်ထားသင့်ပါတယ်။ ဒီ့အပြင် programming paradigms တစ်ခုစီမှာလဲ သူ့ရဲ့ အားသာချက် အားနည်းချက်တွေရှိပါတယ်။ ဆိုတော့ ဒီအားသာချက် အားနည်းချက်တွေသိရင် ကိုယ် ဘာလိုချင်ရင် ဘယ်လိုရေးရမလဲဆိုတာ ရွေးချယ်ပြီးအသုံးပြုနိုင်သွားပါပြီ။ ဥပမာ Parallel Computing အတွက်ဆို ငါဘာသုံးမလဲ? Mathematical Computing အတွက်ဆို ဘာသုံးမလဲ? Lazy Evaluation အတွက်ဆို ဘာသုံးမလဲ? execution time မြန်ဖို့အတွက်? side effect နည်းဖို့အတွက်? အစရှိသဖြင့် ကိုယ်လိုချင်တဲ့ main point ကို ထိရောက်အောင် အလွယ်တကူရေးလာနိုင်ပါမယ်။ ဒီလိုရေးလာနိုင်တာနဲ့အမျှ ကိုယ်ရေးလိုက်တဲ့ program ကလဲ error ကင်းကင်း side effect ရှင်းရှင်း memory leak မရှိ ပေါ့ပေါ့ပါးပါးနဲ့ efficient ဖြစ်လာမှာ အသေအချာပါပဲ။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဒီ Programming Paradigms ထဲက Object-Oriented Programming အကြောင်းဖတ်ချင်ရင်တော့ ဒီမှာပါ။ ကျန်တာတွေလဲ ဆက်ရေးသွားပါမယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; https://www.facebook.com/groups/268145817721147/permalink/342241950311533/</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; အောက်မှာ Programming Paradigms တွေ သိသလောက်ဖော်ပြပေးထားပါတယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Action</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Agent-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Array-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Automata-based</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Concurrent computing</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Relativistic programming</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Data-driven</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Declarative (contrast: Imperative)</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Functional</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Functional logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Purely functional</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Abductive logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Answer set</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Concurrent logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Functional logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Inductive logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Constraint</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Constraint logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Concurrent constraint logic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Dataflow</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Flow-based</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Reactive</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Ontology</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Differentiable</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Dynamic/scripting</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Event-driven</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Function-level (contrast: Value-level)</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Point-free style</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Concatenative</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Generic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Imperative (contrast: Declarative)</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Procedural</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Object-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Polymorphic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Intentional</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Language-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Domain-specific</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Literate</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Natural-language programming</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Metaprogramming</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Automatic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Inductive programming</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Reflective</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Attribute-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Macro</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Template</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Non-structured (contrast: Structured)</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Array</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Nondeterministic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Parallel computing</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Process-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Probabilistic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Quantum</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Set-theoretic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Stack-based</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Structured (contrast: Non-structured)</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Block-structured</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Structured concurrency</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Object-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Actor-based</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Class-based</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Concurrent</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Prototype-based</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; By separation of concerns:</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Aspect-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Role-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Subject-oriented</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Recursive</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Symbolic</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Value-level (contrast: Function-level)</font></div>"
    },
    {
        "id": 10,
        "title": "Declarative Programming and Imperative Programming",
        "category_id": 3,
        "photo": "images/10.jpg",
        "description": "<div><font color='#fff'>ဒီ Programming နှစ်ခုဟာ Language တွေမဟုတ်ပါဘူး Paradigms တွေပါ။ Object-Oriented Programming လိုမျိုး programming paradigms တစ်မျိုးပါ။ ဒါကိုဘာလို့ အရင်ပြောပြရလဲဆိုရင် programming paradigms တွေထဲမှာ အခြေခံကျတဲ့ paradigms တစ်မျိုးလို့ ကျွန်တော်မြင်လို့ပါ။ ဘာလို့မြင်လဲဆိုတော့ ရှေ့လျှောက်ပြောပြမဲ့ Procedural Programming နဲ့ ရှေ့မှာပြောပြခဲ့တဲ့ Object-Oriented Programming ဟာ Imperative Programming Style ကို အသုံးပြုရပြီး Functional Programming, Logic Programming နဲ့ Mathematical Issues တွေမှာ Declarative Programming Style ကို အသုံးပြုရလို့ပါ။ ဒါကြောင့် ဒီနှစ်ခုကို အရင်ရှင်းပြတာပါ။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဒီနှစ်ခုရဲ့ သဘောတရားကို နားလည်လွယ်အောင်ပြောရမယ်ဆိုရင် ကောင်မလေးတစ်ယောက်က ကောင်လေးတစ်ယောက်ကို အဖြေပေးတော့မယ်ပေါ့ဗျာ။ အဖြေကလဲ ငြင်းမဲ့အဖြေဗျာ။ အဲ့တော့ ပထမနည်းက ကောင်လေးကို ကောင်မလေးက ပြန်မချစ်နိုင်ဘူးလို့ ဒဲ့တစ်ခွန်းထဲ ပြောချလိုက်ပြီး ငြင်းတာ။ ဒါ နံပါတ် ၁ နည်းလမ်းပေါ့။ နောက်တစ်နည်းကကျ ကောင်မလေးက ကောင်လေးကို ငါနင့်ကို လောလောတယ် စိတ်မဝင်စားသေးဘူး။ ဒါမဲ့ ငါတို့ သူငယ်ချင်းအဆင့်နဲ့ အရင်နေရအောင်။ နေတာကြာလာရင် စိတ်ဝင်စားလာမှာ blah blah blah...။ ဒါလဲငြင်းတာပဲနော် သိဘို့။ သူငြင်းတဲ့နည်းက ငြင်းတဲ့သူအဖိ်ု့ risk များတယ်။ side effect များတယ်။ အငြင်းခံရတဲ့ကောင်လေးက အနားမှာ ရစ်သီရစ်သီနဲ့ ဆက်အာရုံနောက်နေလို့ရတယ်။ :3 အဲ့တော့ ဒီမှာ မတူတာက ပထမနည်းက ပြတ်တယ်။ ရှင်းရှင်းပဲ။ ဒီနည်းက Declarative Programming ။ သူလုပ်ချင်တာကို သူ ပြတ်ပြတ်သားသား ပေမရှည် အမှားမရှိပဲ အလုပ်လုပ်တယ်။ Short to the point ပဲ။ နောက်တစ်နည်းကကျ ပေရှည်တယ်။ ငြင်းတာပဲ အတူတူပဲ။ ဒီနည်းကကျ imperative Programming ။ သူငြင်းရမယ်ဆိုတဲ့ task တစ်ခုကို ပေရှည်ပြီးလုပ်သွားတာ။ လုပ်တာချင်း အတူတူ Declarative Programming နဲ့ Imperative Programming ဘာကွာလဲဆိုတာ မြင်မယ်ထင်တယ်။ Coding နဲ့ ထပ်ပြပါမယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; JavaScript နဲ့ ပြပါမယ်။ နားလည်လွယ်အောင်ပါ။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Imperative Programming in JavaScript</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; var arr = ['a','b','c','d','e'];</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; for(var i = 0; i &lt; 5; i++){</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(arr[i]);</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; Declarative Programming in JavaScript</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; var arr = ['a','b','c','d','e'];</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; arr.map(item =&gt; console.log(item));</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဒီမှာ ကြည့်မယ်ဆိုရင် Imperative Programming က ရိုးရှင်းပါတယ်။ ကျနော်တို့ array ကို for loop ပတ်ချင်တာပါ။ ဒါကို ပေမရှည်ဘူးလို့ ထင်ကောင်းထင်နိုင်ပါတယ်။ တကယ်တော့ ပေရှည်သလို side effect လဲ များပါတယ်။ for loop ထဲမှာ ထည့်ထားတဲ့ index i က မထည့်တတ်ရင် error တက်တတ်ပါတယ်။ ဒီတော့ ကျွန်တော်တို့ ဒါကို ခပ်ပြတ်ပြတ်ရေးရမယ်ဆိုရင် declarative programming နဲ့ရေးပါမယ်။</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; ဒီ Declarative Programming ကိုကြည့်မယ်ဆိုရင် map function ထည့်ရေးလိုက်တာကို မြင်ရမှာပါ။ အာရုံနောက်စရာ side effect လဲ မရှိပါဘူး။ array မှာ ရှိသလောက် index တွေမကုန်မချင်း သူပတ်ချသွားမယ်။ ဒါပါပဲ။ code လဲ လိုရင်းတိုရှင်းဖြစ်သလို error တက်နိုင်ခြေလဲ နည်းပါတယ်။ ဒါ Imperative Programming နဲ့ Declarative Programming အကြောင်းပါ။ ဒီနည်းလမ်း နှစ်ခုလုံးကို ရေးဖူးမှာပါ။ ဒါမဲ့ Imperative မှန်း Declarative မှန်း အခုမှသိကြတဲ့သူများကိုပြောချင်တာက...</font></div><div><font color='#fff'>&nbsp; &nbsp; &nbsp; &nbsp; မင်းမကြည့်လို့မသိတာပါ။ အချစ်က မင်းအနားမှာ</font></div>"
    }
]